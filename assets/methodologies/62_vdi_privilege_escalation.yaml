id: vdi_privilege_escalation
name: "VDI Host Privilege Escalation and Configuration Flaws"
category: privilege_escalation
description: "Specialized methodology for privilege escalation in VDI environments and exploiting VDI-specific configuration weaknesses"
estimated_duration: "3-4h"
risk_level: high
stealth_level: moderate

# Asset property-based triggers
asset_triggers:
  - id: vdi_host_access_gained
    asset_type: host
    conditions:
      - property: "shell_access"
        operator: "equals"
        value: true
      - or:
        - property: "software_installed"
          operator: "contains"
          value: "citrix"
        - property: "software_installed"
          operator: "contains"
          value: "vmware"
        - property: "software_installed"
          operator: "contains"
          value: "horizon"
        - property: "virtualization"
          operator: "equals"
          value: "vdi"
    trigger_name: "VDI Host Privilege Escalation"
    description: "Trigger when shell access is gained on VDI host"
    priority: 9

  - id: multi_user_vdi_detected
    asset_type: host
    conditions:
      - property: "os_type"
        operator: "equals"
        value: "windows"
      - property: "terminal_services"
        operator: "equals"
        value: true
      - property: "multiple_users"
        operator: "equals"
        value: true
    trigger_name: "Multi-User VDI Exploitation"
    description: "Trigger when multi-user VDI environment detected"
    priority: 8

# Methodology phases
phases:
  # Phase 1: VDI Agent and Software Vulnerability Assessment
  - id: vdi_agent_vulnerabilities
    name: "VDI Agent and Software Vulnerability Assessment"
    description: "Identify and exploit VDI-specific software vulnerabilities"
    order: 1
    steps:
      - id: vdi_agent_enumeration
        name: "VDI Agent and Service Enumeration"
        type: command_group
        description: "Enumerate VDI-specific agents and services"
        order: 1
        commands:
          - platform: windows
            command: |
              # Citrix Virtual Desktop Agent
              Get-Service | Where-Object {$_.DisplayName -like "*Citrix*"}
              Get-Process | Where-Object {$_.ProcessName -like "*Citrix*"}
              reg query "HKLM\SOFTWARE\Citrix"
              Get-ItemProperty "HKLM\SOFTWARE\Citrix\*" -ErrorAction SilentlyContinue

              # VMware Horizon Agent
              Get-Service | Where-Object {$_.DisplayName -like "*VMware*"}
              Get-Process | Where-Object {$_.ProcessName -like "*VMware*"}
              reg query "HKLM\SOFTWARE\VMware, Inc."

              # Microsoft RDS components
              Get-Service | Where-Object {$_.DisplayName -like "*Remote Desktop*"}
              Get-Service TermService
              reg query "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server"
            timeout: "3m"

      - id: vdi_agent_privilege_check
        name: "VDI Agent Privilege Assessment"
        type: command_group
        description: "Check privileges and permissions of VDI agents"
        order: 2
        commands:
          - platform: windows
            command: |
              # Check service privileges and paths
              Get-WmiObject Win32_Service | Where-Object {$_.DisplayName -like "*Citrix*" -or $_.DisplayName -like "*VMware*"} | Select-Object Name, StartName, PathName, StartMode

              # Check for unquoted service paths in VDI services
              Get-WmiObject Win32_Service | Where-Object {$_.PathName -notlike '*"*' -and $_.PathName -like '* *'} | Where-Object {$_.DisplayName -like "*Citrix*" -or $_.DisplayName -like "*VMware*" -or $_.DisplayName -like "*Remote Desktop*"}

              # Check service ACLs
              Get-Acl -Path "HKLM:\SYSTEM\CurrentControlSet\Services\*" | Where-Object {$_.Path -like "*Citrix*" -or $_.Path -like "*VMware*"}
            timeout: "2m"

      - id: vdi_handle_exploitation
        name: "VDI Agent Handle Exploitation"
        type: command_group
        description: "Look for exploitable handles from SYSTEM processes"
        order: 3
        commands:
          - platform: windows
            command: |
              # Check for accessible handles from SYSTEM VDI processes
              tasklist /v | findstr /i "citrix vmware"

              # Use handle.exe if available to check for exploitable handles
              # This targets CVE-2025-6759 style vulnerabilities
              if (Test-Path "C:\tools\handle.exe") {
                C:\tools\handle.exe -p winlogon.exe
                C:\tools\handle.exe -p csrss.exe
              }

              # Check for writable process memory
              Get-Process | Where-Object {$_.ProcessName -like "*citrix*" -or $_.ProcessName -like "*vmware*"} | Select-Object ProcessName, Id, Handles
            timeout: "2m"

      - id: vdi_dll_hijacking_check
        name: "VDI DLL Hijacking Assessment"
        type: command_group
        description: "Check for DLL hijacking opportunities in VDI software"
        order: 4
        commands:
          - platform: windows
            command: |
              # Check VDI software installation directories for weak permissions
              $vdiPaths = @(
                "C:\Program Files\Citrix",
                "C:\Program Files (x86)\Citrix",
                "C:\Program Files\VMware",
                "C:\Program Files (x86)\VMware"
              )

              foreach ($path in $vdiPaths) {
                if (Test-Path $path) {
                  Get-Acl $path | Select-Object Path, Owner, AccessToString
                  Get-ChildItem $path -Recurse -File -Filter "*.exe" | Select-Object FullName, LastWriteTime
                }
              }

              # Check for missing DLLs that could be hijacked
              # This would typically require Process Monitor for dynamic analysis
            timeout: "3m"

        asset_discovery:
          search_patterns:
            - pattern: "Citrix.*Agent.*SYSTEM"
              asset_type: service
              confidence: 1.0
              metadata:
                service_type: "vdi_agent"
                privilege_level: "system"
                exploit_potential: "high"
            - pattern: "VMware.*View.*SYSTEM"
              asset_type: service
              confidence: 1.0
              metadata:
                service_type: "vdi_agent"
                privilege_level: "system"
                exploit_potential: "high"
            - pattern: "unquoted.*service.*path"
              asset_type: vulnerability
              confidence: 0.9
              metadata:
                vuln_type: "unquoted_service_path"
                exploit_method: "service_hijacking"

  # Phase 2: User Environment Manager Exploitation
  - id: user_environment_manager_exploit
    name: "User Environment Manager Exploitation"
    description: "Exploit user environment management systems"
    order: 2
    steps:
      - id: uem_detection
        name: "User Environment Manager Detection"
        type: command_group
        description: "Detect and enumerate UEM systems"
        order: 1
        commands:
          - platform: windows
            command: |
              # AppSense/Ivanti Environment Manager
              Get-Service | Where-Object {$_.DisplayName -like "*AppSense*" -or $_.DisplayName -like "*Ivanti*"}
              Test-Path "C:\Program Files\AppSense"
              Test-Path "C:\Program Files\Ivanti"

              # VMware Dynamic Environment Manager
              Get-Service | Where-Object {$_.DisplayName -like "*VMware DEM*"}
              Test-Path "C:\Program Files\Immidio"

              # Microsoft User Experience Virtualization (UE-V)
              Get-Service | Where-Object {$_.DisplayName -like "*UE-V*"}
              reg query "HKLM\SOFTWARE\Microsoft\UEV"

              # Citrix Profile Management
              Get-Service | Where-Object {$_.DisplayName -like "*Profile*Management*"}
              Test-Path "C:\Program Files\Citrix\User Profile Manager"
            timeout: "2m"

      - id: uem_configuration_review
        name: "UEM Configuration Review"
        type: command_group
        description: "Review UEM configurations for weaknesses"
        order: 2
        commands:
          - platform: windows
            command: |
              # Check UEM policy files for misconfigurations
              $uemPaths = @(
                "C:\Program Files\AppSense\Environment Manager\Policies",
                "C:\Program Files\Ivanti\Environment Manager\Policies",
                "C:\Program Files\Immidio\Flex Profiles\Policies",
                "$env:ProgramData\AppSense",
                "$env:ProgramData\Ivanti"
              )

              foreach ($path in $uemPaths) {
                if (Test-Path $path) {
                  Get-ChildItem $path -Recurse -Filter "*.xml" -ErrorAction SilentlyContinue
                  Get-ChildItem $path -Recurse -Filter "*.ini" -ErrorAction SilentlyContinue
                }
              }

              # Check for writable UEM configuration locations
              $uemConfigPaths = @(
                "$env:USERPROFILE\AppData\Local\AppSense",
                "$env:USERPROFILE\AppData\Roaming\AppSense"
              )

              foreach ($path in $uemConfigPaths) {
                if (Test-Path $path) {
                  Get-Acl $path | Select-Object Path, AccessToString
                }
              }
            timeout: "2m"

  # Phase 3: AppLocker and Software Restriction Policy Bypass
  - id: applocker_srp_bypass
    name: "AppLocker and SRP Bypass in VDI"
    description: "Bypass application whitelisting in VDI environments"
    order: 3
    steps:
      - id: applocker_enumeration
        name: "AppLocker Policy Enumeration"
        type: command_group
        description: "Enumerate AppLocker policies and rules"
        order: 1
        commands:
          - platform: windows
            command: |
              # Get effective AppLocker policy
              Get-AppLockerPolicy -Effective | Export-Clixml C:\temp\applocker_policy.xml

              # Check AppLocker rules
              Get-AppLockerPolicy -Effective -Xml | Out-File C:\temp\applocker_rules.xml

              # Check AppLocker events
              Get-WinEvent -LogName "Microsoft-Windows-AppLocker/EXE and DLL" -MaxEvents 100 -ErrorAction SilentlyContinue | Select-Object TimeCreated, Id, LevelDisplayName, Message

              # Check SRP policies
              reg query "HKLM\SOFTWARE\Policies\Microsoft\Windows\Safer\CodeIdentifiers"
              reg query "HKCU\SOFTWARE\Policies\Microsoft\Windows\Safer\CodeIdentifiers"
            timeout: "2m"

      - id: applocker_bypass_techniques
        name: "AppLocker Bypass Techniques"
        type: command_group
        description: "Attempt various AppLocker bypass methods"
        order: 2
        commands:
          - platform: windows
            command: |
              # Test LOLBin execution
              # InstallUtil bypass
              $installUtilPath = "C:\Windows\Microsoft.NET\Framework64\v4.0.30319\InstallUtil.exe"
              if (Test-Path $installUtilPath) {
                Write-Host "InstallUtil available for bypass: $installUtilPath"
              }

              # MSBuild bypass
              $msbuildPath = "C:\Windows\Microsoft.NET\Framework64\v4.0.30319\MSBuild.exe"
              if (Test-Path $msbuildPath) {
                Write-Host "MSBuild available for bypass: $msbuildPath"
              }

              # RegAsm bypass
              $regasmPath = "C:\Windows\Microsoft.NET\Framework64\v4.0.30319\RegAsm.exe"
              if (Test-Path $regasmPath) {
                Write-Host "RegAsm available for bypass: $regasmPath"
              }

              # Rundll32 bypass testing
              rundll32.exe /? 2>$null
              if ($LASTEXITCODE -eq 0) {
                Write-Host "Rundll32 available for potential bypass"
              }

              # Test writable locations for bypass
              $writableLocations = @(
                "$env:PROGRAMDATA",
                "$env:USERPROFILE\Documents",
                "$env:TEMP",
                "C:\Windows\Tasks"
              )

              foreach ($location in $writableLocations) {
                try {
                  $testFile = "$location\applockertest.txt"
                  "test" | Out-File $testFile
                  Remove-Item $testFile -ErrorAction SilentlyContinue
                  Write-Host "Writable location found: $location"
                } catch {
                  Write-Host "Not writable: $location"
                }
              }
            timeout: "3m"

      - id: lolbin_execution_testing
        name: "Living Off The Land Binary Testing"
        type: command_group
        description: "Test execution via legitimate Windows binaries"
        order: 3
        commands:
          - platform: windows
            command: |
              # Test various LOLBins that might be allowed
              $lolbins = @(
                "powershell.exe",
                "cmd.exe",
                "wmic.exe",
                "certutil.exe",
                "bitsadmin.exe",
                "regsvr32.exe",
                "mshta.exe",
                "cscript.exe",
                "wscript.exe"
              )

              foreach ($binary in $lolbins) {
                $fullPath = (Get-Command $binary -ErrorAction SilentlyContinue).Source
                if ($fullPath) {
                  Write-Host "Available: $binary at $fullPath"
                  # Test basic execution
                  & $binary /? 2>$null
                  Write-Host "Exit code: $LASTEXITCODE"
                }
              }

              # Test PowerShell execution policy
              Get-ExecutionPolicy -List
              powershell.exe -Command "Get-ExecutionPolicy"
              powershell.exe -ExecutionPolicy Bypass -Command "Write-Host 'Bypass successful'"
            timeout: "2m"

  # Phase 4: Multi-User Session Exploitation
  - id: multi_user_session_exploit
    name: "Multi-User Session Exploitation"
    description: "Exploit multi-user RDS/VDI environments"
    order: 4
    steps:
      - id: session_enumeration
        name: "Session Enumeration"
        type: command_group
        description: "Enumerate other user sessions"
        order: 1
        commands:
          - platform: windows
            command: |
              # List all sessions
              qwinsta
              query user
              query session

              # Get detailed session information
              Get-Process -IncludeUserName | Where-Object {$_.UserName} | Group-Object UserName | Sort-Object Count -Descending

              # Check for admin sessions
              qwinsta | findstr /i "admin"
              query user | findstr /i "admin"

              # List processes by session
              tasklist /fi "sessionname eq console"
              tasklist /fi "sessionname ne console"
            timeout: "2m"

      - id: inter_session_communication
        name: "Inter-Session Communication Testing"
        type: command_group
        description: "Test communication between sessions"
        order: 2
        commands:
          - platform: windows
            command: |
              # Test message sending to other sessions
              query user | ForEach-Object {
                if ($_ -match "(\w+)\s+(\d+)\s+") {
                  $username = $matches[1]
                  $sessionId = $matches[2]
                  if ($sessionId -ne $env:SESSIONNAME) {
                    msg $sessionId "Test message from security assessment"
                  }
                }
              }

              # Check for shared resources between sessions
              Get-WmiObject Win32_LogicalDisk | Where-Object {$_.DriveType -eq 3}
              net use

              # Check for session shadowing capabilities (admin required)
              # mstsc /shadow:1 /v:localhost /noconsentprompt
              Write-Host "Session shadowing would require: mstsc /shadow:SessionID /v:localhost"
            timeout: "2m"

      - id: session_hijacking_attempt
        name: "Session Hijacking Attempt"
        type: command_group
        description: "Attempt session hijacking techniques"
        order: 3
        commands:
          - platform: windows
            command: |
              # Check current session privileges
              whoami /priv | findstr /i "debug\|assignprimary\|impersonate\|load\|restore\|backup"

              # Check for session hijacking prerequisites
              $currentUser = $env:USERNAME
              $currentSession = $env:SESSIONNAME

              Write-Host "Current user: $currentUser"
              Write-Host "Current session: $currentSession"

              # Look for high-privilege processes we might be able to use
              Get-Process | Where-Object {$_.ProcessName -in @("winlogon", "lsass", "services")} | Select-Object ProcessName, Id, StartTime

              # Check for vulnerable service configurations
              Get-WmiObject Win32_Service | Where-Object {$_.StartName -like "*LocalService*" -or $_.StartName -like "*NetworkService*"} | Select-Object Name, StartName, PathName
            timeout: "2m"

  # Phase 5: VDI Configuration and Policy Bypass
  - id: vdi_config_policy_bypass
    name: "VDI Configuration and Policy Bypass"
    description: "Bypass VDI-specific configurations and policies"
    order: 5
    steps:
      - id: group_policy_analysis
        name: "Group Policy Analysis"
        type: command_group
        description: "Analyze applied Group Policies for weaknesses"
        order: 1
        commands:
          - platform: windows
            command: |
              # Get detailed Group Policy results
              gpresult /R /V | Out-File C:\temp\gpresult_detailed.txt
              gpresult /Z | Out-File C:\temp\gpresult_full.txt

              # Check for VDI-specific policies
              reg query "HKLM\SOFTWARE\Policies\Citrix" -s -ErrorAction SilentlyContinue
              reg query "HKLM\SOFTWARE\Policies\VMware" -s -ErrorAction SilentlyContinue
              reg query "HKLM\SOFTWARE\Policies\Microsoft\Windows\Terminal Services" -s -ErrorAction SilentlyContinue

              # Check user-specific policies
              reg query "HKCU\SOFTWARE\Policies" -s -ErrorAction SilentlyContinue

              # Look for logon scripts
              reg query "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Startup"
              reg query "HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logon"
            timeout: "3m"

      - id: vdi_registry_bypass
        name: "VDI Registry Bypass Techniques"
        type: command_group
        description: "Attempt registry-based policy bypasses"
        order: 2
        commands:
          - platform: windows
            command: |
              # Test registry modification capabilities
              $testKey = "HKCU\Software\Test"
              try {
                New-Item -Path "HKCU:\Software" -Name "Test" -Force
                Set-ItemProperty -Path "HKCU:\Software\Test" -Name "TestValue" -Value "TestData"
                Remove-Item -Path "HKCU:\Software\Test" -Force
                Write-Host "Registry modification successful"
              } catch {
                Write-Host "Registry modification failed: $_"
              }

              # Common VDI restriction bypass attempts
              $bypassAttempts = @{
                "HKCU\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\NoRun" = 0
                "HKCU\Software\Microsoft\Windows\CurrentVersion\Policies\System\DisableTaskMgr" = 0
                "HKCU\Software\Microsoft\Windows\CurrentVersion\Policies\System\DisableRegistryTools" = 0
                "HKCU\Software\Policies\Microsoft\Windows\System\DisableCMD" = 0
              }

              foreach ($key in $bypassAttempts.Keys) {
                try {
                  $keyPath = Split-Path $key
                  $valueName = Split-Path $key -Leaf
                  if (Test-Path "Registry::$keyPath") {
                    Set-ItemProperty -Path "Registry::$keyPath" -Name $valueName -Value $bypassAttempts[$key] -ErrorAction SilentlyContinue
                    Write-Host "Attempted bypass: $key"
                  }
                } catch {
                  Write-Host "Bypass failed for: $key"
                }
              }
            timeout: "2m"

# Chain triggers
chain_triggers:
  - conditions:
      - outcome: "system_privilege_gained"
        value: true
    trigger: credential_dumping
    priority: 10
    description: "Dump credentials after gaining SYSTEM privileges"

  - conditions:
      - outcome: "applocker_bypassed"
        value: true
    trigger: payload_execution
    priority: 9
    description: "Execute payload after bypassing application controls"

  - conditions:
      - outcome: "multi_user_access"
        value: true
    trigger: lateral_movement
    priority: 8
    description: "Begin lateral movement after accessing other user sessions"

# Outcome schema
outcome_schema:
  system_privilege_gained:
    type: boolean
    description: "Whether SYSTEM privileges were obtained"
    critical: true

  vdi_agent_exploited:
    type: boolean
    description: "Whether VDI agent vulnerabilities were exploited"

  applocker_bypassed:
    type: boolean
    description: "Whether AppLocker/SRP was bypassed"

  multi_user_access:
    type: boolean
    description: "Whether access to other user sessions was gained"

  uem_misconfiguration_found:
    type: boolean
    description: "Whether UEM misconfigurations were found"

  session_hijacking_possible:
    type: boolean
    description: "Whether session hijacking is possible"

  policy_bypass_successful:
    type: array
    items: string
    description: "Successfully bypassed policies"

  vdi_vulnerabilities_found:
    type: array
    items:
      type: object
      properties:
        cve: string
        description: string
        severity: string
        component: string
    description: "VDI-specific vulnerabilities discovered"

# Detection signatures
detection_signatures:
  - name: "VDI Agent Handle Exploitation"
    pattern: "Unusual handle access to SYSTEM VDI processes"
    log_source: "security_events"
    severity: "critical"

  - name: "AppLocker Policy Enumeration"
    pattern: "AppLocker policy export or enumeration"
    log_source: "powershell_logs"
    severity: "medium"

  - name: "Multi-Session Enumeration"
    pattern: "Excessive session enumeration commands"
    log_source: "command_line_logging"
    severity: "medium"

  - name: "Registry Policy Bypass"
    pattern: "Modification of policy-related registry keys"
    log_source: "registry_monitoring"
    severity: "high"

  - name: "LOLBin Execution"
    pattern: "Suspicious use of legitimate Windows binaries"
    log_source: "process_creation"
    severity: "medium"

# Cleanup procedures
cleanup_procedures:
  - description: "Restore registry modifications"
    commands:
      - platform: windows
        command: |
          # Restore any modified registry values
          # This would be specific to what was changed
          Write-Host "Restore any modified registry policies"

  - description: "Remove test files"
    commands:
      - platform: windows
        command: |
          Remove-Item C:\temp\gpresult*.txt -Force -ErrorAction SilentlyContinue
          Remove-Item C:\temp\applocker*.xml -Force -ErrorAction SilentlyContinue

# Suppression options
suppression:
  available_scopes:
    - scope: "privilege_escalation"
      description: "Skip privilege escalation attempts"
      conditions: ["Limited scope", "Production system"]
    - scope: "multi_user"
      description: "Skip multi-user session testing"
      conditions: ["Single user VDI", "Privacy concerns"]
    - scope: "policy_bypass"
      description: "Skip policy bypass testing"
      conditions: ["Compliance restrictions", "Audit requirements"]