# Penetration Testing Asset Model - Implementation Guide

## Overview

This Python implementation provides a comprehensive asset model for penetration testing activities, designed to capture all relevant entities, their properties, relationships, and lifecycle states during security assessments.

## Key Features

### 1. Comprehensive Asset Types

The model includes support for:

- **Network Infrastructure**: Network segments, WiFi networks, firewall rules
- **Systems & Hosts**: Hosts, domain controllers, with OS and configuration details
- **Services & Applications**: Network services, web applications, API endpoints
- **Identity & Access**: Users, groups, credentials with privilege tracking
- **Cloud Resources**: Cloud accounts, instances, storage buckets
- **Data Storage**: Databases, file shares with sensitivity classification
- **Security Controls**: Firewall rules, certificates

### 2. Relationship Management

Assets can have typed relationships:

```python
# Example relationships
network.add_relationship(RelationshipType.CONTAINS, host.id)
service.add_relationship(RelationshipType.RUNS_ON, host.id)
user.add_relationship(RelationshipType.MEMBER_OF, group.id)
credential.add_relationship(RelationshipType.AUTHENTICATES, system.id)
```

### 3. Lifecycle State Management

Assets progress through lifecycle states:

```
UNDISCOVERED → DISCOVERED → VALIDATED → ENUMERATED → TESTED → EXPLOITED → CONTROLLED
```

State transitions are tracked with metadata:

```python
asset.transition_state(
    LifecycleState.EXPLOITED,
    trigger="CVE-2021-41773 exploited",
    notes="Shell obtained"
)
```

### 4. Property-Based Trigger System

Integrates with the asset-driven trigger system for methodology orchestration:

```python
# Define triggers based on asset properties
trigger = MethodologyTrigger(
    methodology_id="nac_credential_testing",
    asset_type="network_segment",
    conditions=[
        TriggerCondition("nac_enabled", "equals", True),
        TriggerCondition("credentials_available", "exists")
    ],
    deduplication_template="{asset_id}:nac_cred:{properties_hash}"
)

# Detect triggers for assets
engine = TriggerEngine(repository)
detected = engine.detect_triggers_for_asset(network)
```

### 5. Advanced Query Capabilities

Powerful query engine with fluent API:

```python
query = QueryEngine(repository)

# Find high-risk assets
high_risk = query.query() \
    .where_risk_score("greater_than", 7.0) \
    .execute()

# Find compromised assets
compromised = query.find_compromised_assets()

# Find valid admin credentials
admins = query.query() \
    .where_type("credential") \
    .where("privilege_level", "in", ["admin", "domain_admin"]) \
    .where("validity_status", "equals", "valid") \
    .execute()
```

### 6. Risk Scoring

Automatic risk score calculation based on:

- Asset type criticality
- Exposure level (internet-facing, DMZ, internal)
- Known vulnerabilities
- Privilege level
- Lifecycle state
- Public accessibility

```python
# Calculate risk for all assets
risk_profile = RiskScorer.calculate_repository_risk_profile(repo)
# Returns: average, max, high/medium/low counts, by-type breakdown
```

### 7. Import/Export Capabilities

Multiple export formats:

```python
from pentest_asset_model.utils import ImportExport

# JSON export (complete data)
ImportExport.export_to_json(repo, "assets.json")

# CSV export (one file per asset type)
ImportExport.export_to_csv(repo, "csv_output/")

# GraphML (for visualization in tools like Gephi, yEd)
ImportExport.export_to_graphml(repo, "asset_graph.graphml")

# Summary report (human-readable)
ImportExport.export_summary_report(repo, "report.txt")
```

## Quick Start

### Installation

```bash
cd python_spike
pip install -r requirements.txt
```

### Basic Usage

```python
from pentest_asset_model import AssetRepository
from pentest_asset_model.models import NetworkSegment, Host, Service
from pentest_asset_model.services import QueryEngine, TriggerEngine

# Create repository
repo = AssetRepository()

# Add assets
network = NetworkSegment(
    id="net_1",
    name="DMZ Network",
    cidr="203.0.113.0/24"
)
repo.add_asset(network)

host = Host(
    id="host_1",
    hostname="webserver",
    ip="203.0.113.10"
)
repo.add_asset(host)

# Create relationships
network.add_host(host.id)

# Query assets
query = QueryEngine(repo)
hosts = query.find_assets(asset_type="host")

# Detect methodology triggers
triggers = TriggerEngine(repo)
triggers.create_example_triggers()
detected = triggers.detect_all_triggers()
```

### Running the Example Scenario

```bash
cd pentest_asset_model/examples
python corporate_network_scenario.py
```

This runs a comprehensive penetration test scenario demonstrating:

1. External reconnaissance
2. Initial access via vulnerability
3. Network enumeration
4. Credential harvesting
5. Lateral movement
6. Privilege escalation
7. Trigger-based methodology detection
8. Risk assessment

## Architecture

### Core Components

```
pentest_asset_model/
├── models/              # Asset model classes
│   ├── base.py         # Base Asset class, enums, relationships
│   ├── network.py      # Network infrastructure models
│   ├── systems.py      # Host and system models
│   ├── services.py     # Service and application models
│   ├── identity.py     # User, group, credential models
│   ├── cloud.py        # Cloud resource models
│   └── data_storage.py # Database and file share models
│
├── services/           # Business logic
│   ├── repository.py   # AssetRepository (storage, CRUD)
│   ├── query.py        # QueryEngine (advanced queries)
│   └── triggers.py     # TriggerEngine (methodology detection)
│
├── utils/              # Utilities
│   ├── import_export.py # Import/export functions
│   └── risk_scoring.py  # Risk calculation
│
└── examples/           # Usage examples
    └── corporate_network_scenario.py
```

### Design Patterns

1. **Repository Pattern**: Central `AssetRepository` for asset storage and retrieval
2. **Builder Pattern**: `QueryBuilder` for fluent query construction
3. **Strategy Pattern**: Risk scoring strategies based on asset properties
4. **Observer Pattern**: Trigger detection responds to asset property changes

## Integration with Madness

This asset model integrates with the Madness Flutter application's trigger system described in `ASSET_DRIVEN_TRIGGER_SYSTEM.md`:

### Property-Based Triggers

```python
# Network with NAC enabled + credentials → trigger NAC bypass
network.update_property("nac_enabled", True)
network.add_credential("user1", password="pass123")

# Automatically detected by trigger engine
triggers = engine.detect_triggers_for_asset(network)
# Returns: nac_credential_testing trigger
```

### Batch Command Generation

```python
# Multiple web services → batch enumeration
for service in web_services:
    network.add_web_service(service.host, service.port, "http")

# Group into batch operations
batch_groups = engine.group_batch_triggers(detected_triggers)
# Generates: single eyewitness command for all services
```

### Deduplication

```python
# Prevents redundant execution
dedup_key = trigger.generate_deduplication_key(asset)
if not engine.is_trigger_completed(dedup_key):
    # Execute methodology
    pass
```

## Extension Points

### Adding New Asset Types

```python
from pentest_asset_model.models.base import Asset, AssetType

class CustomAsset(Asset):
    def __init__(self, id: str, name: str, **kwargs):
        super().__init__(
            id=id,
            asset_type=AssetType.CUSTOM,  # Add to enum
            name=name,
            **kwargs
        )
        self.properties.update({
            "custom_property": None
        })
```

### Custom Queries

```python
def find_custom_assets(query_engine: QueryEngine) -> List[Asset]:
    return query_engine.query() \
        .where("custom_property", "exists") \
        .where_custom(lambda a: custom_logic(a)) \
        .execute()
```

### Custom Triggers

```python
custom_trigger = MethodologyTrigger(
    methodology_id="custom_methodology",
    asset_type="host",
    conditions=[
        TriggerCondition("custom_property", "equals", "target_value")
    ],
    command_template="custom_tool --target {ip_address}"
)

engine.register_trigger(custom_trigger)
```

## Best Practices

### 1. Asset Discovery

```python
# Set discovery method
asset.discovery_method = DiscoveryMethod.NETWORK_SCAN

# Track confidence
asset.confidence = 0.9  # 0.0 to 1.0

# Add discovery notes
asset.notes = "Discovered via nmap scan"
```

### 2. Relationship Management

```python
# Always use typed relationships
asset.add_relationship(
    RelationshipType.DEPENDS_ON,
    target_id,
    discovery_method=DiscoveryMethod.SERVICE_ENUMERATION,
    confidence=0.8
)
```

### 3. State Transitions

```python
# Only transition through valid states
try:
    asset.transition_state(
        LifecycleState.EXPLOITED,
        trigger="Vulnerability exploited",
        notes="Details about exploitation"
    )
except ValueError as e:
    # Invalid transition
    pass
```

### 4. Risk Management

```python
# Recalculate risk scores after significant changes
for asset in repo.get_all_assets():
    asset.risk_score = RiskScorer.calculate_risk_score(asset)
```

## Performance Considerations

- Repository uses in-memory storage (for spike/prototype)
- Indexed by asset type and relationships
- Query builder supports filtering at multiple levels
- Batch operations reduce trigger redundancy

## Future Enhancements

1. **Persistent Storage**: Add database backend (SQLite, PostgreSQL)
2. **Graph Database**: Neo4j integration for relationship traversal
3. **Event System**: Publish asset changes for real-time updates
4. **Import Parsers**: Nmap XML, Nessus, Bloodhound data
5. **STIX 2.1 Export**: Threat intelligence format
6. **Visualization**: Built-in graph visualization
7. **Machine Learning**: Anomaly detection, risk prediction

## License

Part of the Madness penetration testing framework.

## Contributing

This is a spike/prototype. Feedback and enhancements welcome!
