"""Risk scoring utilities for assets"""

from typing import Dict
from pentest_asset_model.models.base import Asset, AssetType, LifecycleState


class RiskScorer:
    """Calculate risk scores for assets based on various factors"""

    # Base risk scores by asset type
    ASSET_TYPE_RISK = {
        AssetType.DOMAIN_CONTROLLER: 10.0,
        AssetType.DATABASE: 8.0,
        AssetType.CLOUD_ACCOUNT: 8.0,
        AssetType.CREDENTIAL: 7.0,
        AssetType.HOST: 5.0,
        AssetType.SERVICE: 4.0,
        AssetType.APPLICATION: 5.0,
        AssetType.STORAGE_BUCKET: 6.0,
        AssetType.FILE_SHARE: 5.0,
        AssetType.USER: 3.0,
        AssetType.NETWORK_SEGMENT: 4.0,
    }

    # Exposure multipliers
    EXPOSURE_MULTIPLIER = {
        "internet_facing": 2.0,
        "dmz": 1.5,
        "internal": 1.0,
        "restricted": 1.2,
    }

    # Vulnerability severity scores
    VULNERABILITY_SCORES = {
        "critical": 10.0,
        "high": 7.0,
        "medium": 4.0,
        "low": 1.0,
    }

    # Privilege level multipliers
    PRIVILEGE_MULTIPLIER = {
        "root": 2.0,
        "system": 2.0,
        "enterprise_admin": 2.0,
        "domain_admin": 1.8,
        "admin": 1.5,
        "power_user": 1.2,
        "user": 1.0,
    }

    @classmethod
    def calculate_risk_score(cls, asset: Asset) -> float:
        """
        Calculate comprehensive risk score for an asset.

        Factors considered:
        - Asset type criticality
        - Exposure level
        - Vulnerabilities
        - Privilege level
        - Lifecycle state
        - Public accessibility
        """
        # Start with base asset type risk
        base_score = cls.ASSET_TYPE_RISK.get(asset.asset_type, 3.0)

        # Apply exposure multiplier
        exposure = cls._get_exposure_factor(asset)
        score = base_score * exposure

        # Add vulnerability score
        vuln_score = cls._calculate_vulnerability_score(asset)
        score += vuln_score

        # Apply privilege multiplier
        privilege = cls._get_privilege_multiplier(asset)
        score *= privilege

        # Apply lifecycle state multiplier
        state_mult = cls._get_state_multiplier(asset.lifecycle_state)
        score *= state_mult

        # Apply public accessibility bonus
        if cls._is_publicly_accessible(asset):
            score *= 1.5

        # Cap at 10.0
        return min(score, 10.0)

    @classmethod
    def _get_exposure_factor(cls, asset: Asset) -> float:
        """Get exposure factor based on security zone or location"""
        security_zone = asset.get_property("security_zone")
        if security_zone:
            return cls.EXPOSURE_MULTIPLIER.get(security_zone.lower(), 1.0)

        if asset.get_property("publicly_accessible"):
            return 2.0

        return 1.0

    @classmethod
    def _calculate_vulnerability_score(cls, asset: Asset) -> float:
        """Calculate score based on vulnerabilities"""
        vulnerabilities = asset.get_property("vulnerabilities", [])
        if not vulnerabilities:
            return 0.0

        total_score = 0.0
        for vuln in vulnerabilities:
            severity = vuln.get("severity", "low").lower()
            total_score += cls.VULNERABILITY_SCORES.get(severity, 1.0)

        # Average and cap
        return min(total_score / len(vulnerabilities), 5.0)

    @classmethod
    def _get_privilege_multiplier(cls, asset: Asset) -> float:
        """Get multiplier based on privilege level"""
        privilege_level = asset.get_property("privilege_level")
        if privilege_level:
            return cls.PRIVILEGE_MULTIPLIER.get(privilege_level.lower(), 1.0)

        # Check if asset is marked as privileged
        if asset.get_property("privileged"):
            return 1.5

        return 1.0

    @classmethod
    def _get_state_multiplier(cls, state: LifecycleState) -> float:
        """Get multiplier based on lifecycle state"""
        multipliers = {
            LifecycleState.CONTROLLED: 1.5,
            LifecycleState.EXPLOITED: 1.3,
            LifecycleState.TESTED: 1.1,
            LifecycleState.ENUMERATED: 1.0,
            LifecycleState.VALIDATED: 1.0,
            LifecycleState.DISCOVERED: 0.9,
        }
        return multipliers.get(state, 1.0)

    @classmethod
    def _is_publicly_accessible(cls, asset: Asset) -> bool:
        """Check if asset is publicly accessible"""
        # Check various properties that indicate public access
        if asset.get_property("publicly_accessible"):
            return True
        if asset.get_property("public_ip"):
            return True
        if asset.get_property("world_readable"):
            return True
        if asset.get_property("anonymous_access"):
            return True

        # Check ACL for cloud resources
        acl = asset.get_property("acl")
        if acl and "public" in acl.lower():
            return True

        return False

    @classmethod
    def calculate_repository_risk_profile(cls, repository) -> Dict[str, float]:
        """Calculate risk profile for entire repository"""
        from pentest_asset_model.services.repository import AssetRepository

        if not isinstance(repository, AssetRepository):
            raise ValueError("Expected AssetRepository instance")

        risk_profile = {
            "average_risk": 0.0,
            "max_risk": 0.0,
            "high_risk_count": 0,
            "medium_risk_count": 0,
            "low_risk_count": 0,
            "by_type": {}
        }

        assets = repository.get_all_assets()
        if not assets:
            return risk_profile

        total_risk = 0.0
        max_risk = 0.0

        for asset in assets:
            risk = cls.calculate_risk_score(asset)
            asset.risk_score = risk
            total_risk += risk
            max_risk = max(max_risk, risk)

            # Categorize
            if risk >= 7.0:
                risk_profile["high_risk_count"] += 1
            elif risk >= 4.0:
                risk_profile["medium_risk_count"] += 1
            else:
                risk_profile["low_risk_count"] += 1

            # By type
            asset_type = asset.asset_type.value
            if asset_type not in risk_profile["by_type"]:
                risk_profile["by_type"][asset_type] = {
                    "count": 0,
                    "total_risk": 0.0,
                    "avg_risk": 0.0
                }

            risk_profile["by_type"][asset_type]["count"] += 1
            risk_profile["by_type"][asset_type]["total_risk"] += risk

        # Calculate averages
        risk_profile["average_risk"] = total_risk / len(assets)
        risk_profile["max_risk"] = max_risk

        for type_stats in risk_profile["by_type"].values():
            if type_stats["count"] > 0:
                type_stats["avg_risk"] = type_stats["total_risk"] / type_stats["count"]

        return risk_profile
