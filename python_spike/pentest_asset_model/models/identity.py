"""Identity and access management asset models"""

from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from typing import Optional

from pentest_asset_model.models.base import (
    Asset,
    AssetType,
    RelationshipType,
)


class UserType(Enum):
    """User account types"""
    LOCAL = "local"
    DOMAIN = "domain"
    SERVICE = "service"
    APPLICATION = "application"
    ADMINISTRATOR = "administrator"


class CredentialType(Enum):
    """Types of credentials"""
    PASSWORD = "password"
    HASH = "hash"
    CERTIFICATE = "certificate"
    SSH_KEY = "ssh_key"
    API_KEY = "api_key"
    TOKEN = "token"
    BEARER_TOKEN = "bearer_token"
    COOKIE = "cookie"
    SESSION = "session"


class HashType(Enum):
    """Password hash types"""
    NTLM = "ntlm"
    LM = "lm"
    MD5 = "md5"
    SHA1 = "sha1"
    SHA256 = "sha256"
    SHA512 = "sha512"
    BCRYPT = "bcrypt"
    ARGON2 = "argon2"


class PrivilegeLevel(Enum):
    """Privilege levels"""
    USER = "user"
    POWER_USER = "power_user"
    ADMIN = "admin"
    DOMAIN_ADMIN = "domain_admin"
    ENTERPRISE_ADMIN = "enterprise_admin"
    SYSTEM = "system"
    ROOT = "root"


class ValidityStatus(Enum):
    """Credential validity status"""
    VALID = "valid"
    EXPIRED = "expired"
    LOCKED = "locked"
    DISABLED = "disabled"
    UNKNOWN = "unknown"


class GroupScope(Enum):
    """Active Directory group scopes"""
    LOCAL = "local"
    DOMAIN_LOCAL = "domain_local"
    GLOBAL = "global"
    UNIVERSAL = "universal"


class GroupType(Enum):
    """Group types"""
    SECURITY = "security"
    DISTRIBUTION = "distribution"


@dataclass
class User(Asset):
    """Represents a user account"""

    def __init__(
        self,
        id: str,
        username: str,
        user_type: UserType = UserType.LOCAL,
        **kwargs
    ):
        super().__init__(
            id=id,
            asset_type=AssetType.USER,
            name=username,
            **kwargs
        )

        # Initialize user-specific properties
        self.properties.update({
            "username": username,
            "display_name": username,
            "email": None,
            "user_type": user_type.value if isinstance(user_type, UserType) else user_type,
            "enabled": True,
            "last_logon": None,
            "password_last_set": None,
            "password_expires": None,
            "password_never_expires": False,
            "privileged": False,
            "groups": [],
            "assigned_credentials": [],
            "mfa_enabled": False,
            "account_lockout": False,
            "description": None,
            "sid": None,  # Windows SID
            "uid": None,  # Unix UID
            "home_directory": None,
            "shell": None,  # Unix shell
            "locked_out": False,
            "password_required": True,
            "can_change_password": True,
        })

    def set_email(self, email: str):
        """Set user email"""
        self.properties["email"] = email

    def add_to_group(self, group_id: str):
        """Add user to group"""
        self.add_relationship(RelationshipType.MEMBER_OF, group_id)
        if group_id not in self.properties.get("groups", []):
            self.properties.setdefault("groups", []).append(group_id)

    def assign_credential(self, credential_id: str):
        """Assign credential to user"""
        self.add_relationship(RelationshipType.AUTHENTICATES, credential_id)
        if credential_id not in self.properties.get("assigned_credentials", []):
            self.properties.setdefault("assigned_credentials", []).append(credential_id)

    def set_privileged(self, privileged: bool = True):
        """Mark user as privileged"""
        self.properties["privileged"] = privileged

    def enable_mfa(self):
        """Enable MFA for user"""
        self.properties["mfa_enabled"] = True

    def lock_account(self):
        """Lock user account"""
        self.properties["account_lockout"] = True
        self.properties["locked_out"] = True

    def set_password_policy(self, never_expires: bool = False, required: bool = True):
        """Set password policy"""
        self.properties["password_never_expires"] = never_expires
        self.properties["password_required"] = required

    def set_last_logon(self, timestamp: datetime):
        """Set last logon time"""
        self.properties["last_logon"] = timestamp.isoformat()

    def is_privileged(self) -> bool:
        """Check if user is privileged"""
        return self.properties.get("privileged", False)

    def is_active(self) -> bool:
        """Check if account is active"""
        return self.properties.get("enabled", False) and \
               not self.properties.get("locked_out", False)


@dataclass
class Group(Asset):
    """Represents a security or distribution group"""

    def __init__(
        self,
        id: str,
        name: str,
        group_type: GroupType = GroupType.SECURITY,
        scope: GroupScope = GroupScope.LOCAL,
        **kwargs
    ):
        super().__init__(
            id=id,
            asset_type=AssetType.GROUP,
            name=name,
            **kwargs
        )

        # Initialize group-specific properties
        self.properties.update({
            "type": group_type.value if isinstance(group_type, GroupType) else group_type,
            "scope": scope.value if isinstance(scope, GroupScope) else scope,
            "description": None,
            "members": [],
            "nested_groups": [],
            "privileges": [],
            "sid": None,
            "gid": None,  # Unix GID
            "distinguished_name": None,
        })

    def add_member(self, user_id: str):
        """Add member to group"""
        if user_id not in self.properties.get("members", []):
            self.properties.setdefault("members", []).append(user_id)

    def add_nested_group(self, group_id: str):
        """Add nested group"""
        self.add_relationship(RelationshipType.MEMBER_OF, group_id)
        if group_id not in self.properties.get("nested_groups", []):
            self.properties.setdefault("nested_groups", []).append(group_id)

    def add_privilege(self, privilege: str):
        """Add privilege"""
        privileges = self.properties.get("privileges", [])
        if privilege not in privileges:
            privileges.append(privilege)
            self.properties["privileges"] = privileges

    def set_description(self, description: str):
        """Set group description"""
        self.properties["description"] = description


@dataclass
class Credential(Asset):
    """Represents authentication credentials"""

    def __init__(
        self,
        id: str,
        username: str,
        credential_type: CredentialType,
        value: Optional[str] = None,
        **kwargs
    ):
        super().__init__(
            id=id,
            asset_type=AssetType.CREDENTIAL,
            name=f"{username}:{credential_type.value if isinstance(credential_type, CredentialType) else credential_type}",
            **kwargs
        )

        # Initialize credential-specific properties
        self.properties.update({
            "credential_type": credential_type.value if isinstance(credential_type, CredentialType) else credential_type,
            "username": username,
            "value": value,  # Should be encrypted in production
            "hash_type": None,
            "validity_status": ValidityStatus.UNKNOWN.value,
            "privilege_level": PrivilegeLevel.USER.value,
            "scope": [],  # System IDs where valid
            "discovered_from": None,
            "discovery_method": None,
            "tested_against": [],
            "successful_logins": [],
            "failed_logins": [],
            "password_complexity": None,
            "cracked": False,
            "cleartext_password": None,
        })

    def set_hash_type(self, hash_type: HashType):
        """Set hash type"""
        if isinstance(hash_type, str):
            hash_type = HashType(hash_type)
        self.properties["hash_type"] = hash_type.value

    def set_validity(self, status: ValidityStatus):
        """Set validity status"""
        if isinstance(status, str):
            status = ValidityStatus(status)
        self.properties["validity_status"] = status.value

    def set_privilege_level(self, level: PrivilegeLevel):
        """Set privilege level"""
        if isinstance(level, str):
            level = PrivilegeLevel(level)
        self.properties["privilege_level"] = level.value

    def add_scope(self, system_id: str):
        """Add system where credential is valid"""
        if system_id not in self.properties.get("scope", []):
            self.properties.setdefault("scope", []).append(system_id)

    def test_against(self, system_id: str, success: bool):
        """Record credential test"""
        tested = self.properties.get("tested_against", [])
        if system_id not in tested:
            tested.append(system_id)
            self.properties["tested_against"] = tested

        if success:
            successful = self.properties.get("successful_logins", [])
            if system_id not in successful:
                successful.append(system_id)
                self.properties["successful_logins"] = successful
                self.properties["validity_status"] = ValidityStatus.VALID.value
        else:
            failed = self.properties.get("failed_logins", [])
            if system_id not in failed:
                failed.append(system_id)
                self.properties["failed_logins"] = failed

    def mark_cracked(self, cleartext_password: str):
        """Mark credential as cracked"""
        self.properties["cracked"] = True
        self.properties["cleartext_password"] = cleartext_password
        self.properties["validity_status"] = ValidityStatus.VALID.value

    def set_discovered_from(self, source: str, method: str = None):
        """Set discovery source"""
        self.properties["discovered_from"] = source
        if method:
            self.properties["discovery_method"] = method

    def is_valid(self) -> bool:
        """Check if credential is valid"""
        return self.properties.get("validity_status") == ValidityStatus.VALID.value

    def is_privileged(self) -> bool:
        """Check if credential has elevated privileges"""
        level = self.properties.get("privilege_level")
        return level in [
            PrivilegeLevel.ADMIN.value,
            PrivilegeLevel.DOMAIN_ADMIN.value,
            PrivilegeLevel.ENTERPRISE_ADMIN.value,
            PrivilegeLevel.SYSTEM.value,
            PrivilegeLevel.ROOT.value,
        ]
