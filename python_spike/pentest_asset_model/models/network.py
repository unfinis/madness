"""Network infrastructure asset models"""

from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Dict, List, Optional
import ipaddress

from pentest_asset_model.models.base import (
    Asset,
    AssetType,
    DiscoveryMethod,
    LifecycleState,
)


class SecurityZone(Enum):
    """Network security zones"""
    DMZ = "dmz"
    INTERNAL = "internal"
    RESTRICTED = "restricted"
    EXTERNAL = "external"
    MANAGEMENT = "management"
    GUEST = "guest"
    IOT = "iot"


class NACType(Enum):
    """Network Access Control types"""
    IEEE_802_1X = "802.1x"
    MAC_BASED = "mac_based"
    PORTAL = "portal"
    AGENT_BASED = "agent_based"
    NONE = "none"


class RoutingProtocol(Enum):
    """Routing protocols"""
    STATIC = "static"
    OSPF = "ospf"
    BGP = "bgp"
    EIGRP = "eigrp"
    RIP = "rip"


class AccessLevel(Enum):
    """Network access levels"""
    PHYSICAL = "physical"
    LAYER2 = "layer2"
    LAYER3 = "layer3"
    APPLICATION = "application"
    BLOCKED = "blocked"
    LIMITED = "limited"
    PARTIAL = "partial"
    FULL = "full"


class WiFiAuthType(Enum):
    """WiFi authentication types"""
    OPEN = "open"
    WEP = "wep"
    WPA = "wpa"
    WPA2 = "wpa2"
    WPA3 = "wpa3"
    ENTERPRISE = "enterprise"


class WiFiEncryption(Enum):
    """WiFi encryption types"""
    NONE = "none"
    WEP = "wep"
    TKIP = "tkip"
    AES = "aes"
    GCMP = "gcmp"


class EAPMethod(Enum):
    """EAP authentication methods"""
    PEAP = "peap"
    EAP_TLS = "eap_tls"
    EAP_TTLS = "eap_ttls"
    EAP_FAST = "eap_fast"
    EAP_MD5 = "eap_md5"


@dataclass
class NetworkSegment(Asset):
    """Represents a network segment or subnet"""

    def __init__(
        self,
        id: str,
        name: str,
        cidr: str,
        security_zone: SecurityZone = SecurityZone.INTERNAL,
        **kwargs
    ):
        super().__init__(
            id=id,
            asset_type=AssetType.NETWORK_SEGMENT,
            name=name,
            **kwargs
        )

        # Validate and store CIDR
        try:
            network = ipaddress.ip_network(cidr, strict=False)
        except ValueError as e:
            raise ValueError(f"Invalid CIDR notation: {cidr}") from e

        # Initialize network-specific properties
        self.properties.update({
            "cidr": cidr,
            "network_address": str(network.network_address),
            "broadcast_address": str(network.broadcast_address),
            "netmask": str(network.netmask),
            "num_addresses": network.num_addresses,
            "security_zone": security_zone.value if isinstance(security_zone, SecurityZone) else security_zone,
            "vlans": [],
            "gateway_ips": [],
            "dns_servers": [],
            "dhcp_range": None,
            "nac_enabled": False,
            "nac_type": NACType.NONE.value,
            "routing_protocol": None,
            "access_level": AccessLevel.BLOCKED.value,
            "egress_rules": [],
            "interconnects": [],
            "live_hosts": [],
            "web_services": [],
            "smb_hosts": [],
            "domain_controllers": [],
            "credentials_available": [],
            "certificates_found": [],
            "bypass_methods_attempted": [],
        })

    def add_host(self, host_id: str):
        """Add a host to this network segment"""
        from pentest_asset_model.models.base import RelationshipType
        self.add_relationship(RelationshipType.CONTAINS, host_id)
        if host_id not in self.properties.get("live_hosts", []):
            self.properties.setdefault("live_hosts", []).append(host_id)

    def add_web_service(self, host: str, port: int, service: str, **kwargs):
        """Add a web service to the discovered services"""
        web_service = {
            "host": host,
            "port": port,
            "service": service,
            **kwargs
        }
        self.properties.setdefault("web_services", []).append(web_service)

    def add_credential(self, username: str, password: str = None, hash_val: str = None, source: str = None):
        """Add discovered credentials"""
        credential = {
            "username": username,
            "source": source
        }
        if password:
            credential["password"] = password
        if hash_val:
            credential["hash"] = hash_val

        self.properties.setdefault("credentials_available", []).append(credential)

    def set_access_level(self, level: AccessLevel):
        """Set the current access level to this network"""
        if isinstance(level, str):
            level = AccessLevel(level)
        self.properties["access_level"] = level.value

    def enable_nac(self, nac_type: NACType):
        """Enable NAC on this network"""
        self.properties["nac_enabled"] = True
        if isinstance(nac_type, str):
            nac_type = NACType(nac_type)
        self.properties["nac_type"] = nac_type.value

    def is_accessible(self) -> bool:
        """Check if network is currently accessible"""
        access_level = self.properties.get("access_level", AccessLevel.BLOCKED.value)
        return access_level not in [AccessLevel.BLOCKED.value, "blocked"]


@dataclass
class WiFiNetwork(Asset):
    """Represents a WiFi network"""

    def __init__(
        self,
        id: str,
        ssid: str,
        bssid: str,
        auth_type: WiFiAuthType = WiFiAuthType.OPEN,
        **kwargs
    ):
        super().__init__(
            id=id,
            asset_type=AssetType.WIFI_NETWORK,
            name=ssid,
            **kwargs
        )

        # Initialize WiFi-specific properties
        self.properties.update({
            "ssid": ssid,
            "bssid": bssid,
            "auth_type": auth_type.value if isinstance(auth_type, WiFiAuthType) else auth_type,
            "encryption": WiFiEncryption.NONE.value,
            "eap_method": None,
            "hidden": False,
            "channel": None,
            "frequency": None,  # 2.4 or 5 GHz
            "signal_strength": None,  # dBm
            "network_segment_id": None,
            "handshake_captured": False,
            "cracked": False,
            "password": None,
        })

    def set_encryption(self, encryption: WiFiEncryption):
        """Set the encryption type"""
        if isinstance(encryption, str):
            encryption = WiFiEncryption(encryption)
        self.properties["encryption"] = encryption.value

    def set_eap_method(self, eap_method: EAPMethod):
        """Set the EAP method for enterprise networks"""
        if isinstance(eap_method, str):
            eap_method = EAPMethod(eap_method)
        self.properties["eap_method"] = eap_method.value

    def capture_handshake(self):
        """Mark that a handshake has been captured"""
        self.properties["handshake_captured"] = True

    def set_cracked(self, password: str):
        """Mark network as cracked with password"""
        self.properties["cracked"] = True
        self.properties["password"] = password

    def is_vulnerable(self) -> bool:
        """Check if network has known vulnerabilities"""
        auth = self.properties.get("auth_type")
        encryption = self.properties.get("encryption")

        # Check for weak authentication/encryption
        return auth in [WiFiAuthType.OPEN.value, WiFiAuthType.WEP.value] or \
               encryption in [WiFiEncryption.NONE.value, WiFiEncryption.WEP.value]


@dataclass
class FirewallRule(Asset):
    """Represents a firewall rule"""

    def __init__(
        self,
        id: str,
        name: str,
        rule_number: int,
        action: str = "allow",
        **kwargs
    ):
        super().__init__(
            id=id,
            asset_type=AssetType.FIREWALL_RULE,
            name=name,
            **kwargs
        )

        self.properties.update({
            "rule_number": rule_number,
            "action": action,  # allow, deny, reject
            "direction": "inbound",  # inbound, outbound
            "source": None,
            "destination": None,
            "service": None,
            "port_range": None,
            "protocol": "any",  # tcp, udp, icmp, any
            "enabled": True,
            "logged": False,
            "firewall_id": None,
        })
