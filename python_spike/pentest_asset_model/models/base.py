"""Base asset model classes and enumerations"""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional
import uuid
import json


class AssetType(Enum):
    """Types of assets in penetration testing"""
    NETWORK_SEGMENT = "network_segment"
    WIFI_NETWORK = "wifi_network"
    HOST = "host"
    DOMAIN_CONTROLLER = "domain_controller"
    SERVICE = "service"
    APPLICATION = "application"
    API_ENDPOINT = "api_endpoint"
    DATABASE = "database"
    FILE_SHARE = "file_share"
    USER = "user"
    GROUP = "group"
    CREDENTIAL = "credential"
    CLOUD_ACCOUNT = "cloud_account"
    CLOUD_INSTANCE = "cloud_instance"
    STORAGE_BUCKET = "storage_bucket"
    FIREWALL_RULE = "firewall_rule"
    CERTIFICATE = "certificate"


class LifecycleState(Enum):
    """Lifecycle states for assets during testing"""
    UNDISCOVERED = "undiscovered"
    DISCOVERED = "discovered"
    VALIDATED = "validated"
    ENUMERATED = "enumerated"
    TESTED = "tested"
    EXPLOITED = "exploited"
    CONTROLLED = "controlled"
    CLEANED = "cleaned"
    STALE = "stale"


class DiscoveryMethod(Enum):
    """Methods by which assets are discovered"""
    MANUAL_ENTRY = "manual_entry"
    NETWORK_SCAN = "network_scan"
    PORT_SCAN = "port_scan"
    SERVICE_ENUMERATION = "service_enumeration"
    CREDENTIAL_SPRAY = "credential_spray"
    API_ENUMERATION = "api_enumeration"
    CERTIFICATE_TRANSPARENCY = "certificate_transparency"
    DNS_ENUMERATION = "dns_enumeration"
    OSINT = "osint"
    DOCUMENT_ANALYSIS = "document_analysis"
    USER_PROVIDED = "user_provided"
    DERIVED = "derived"
    VULNERABILITY_SCAN = "vulnerability_scan"
    BLOODHOUND = "bloodhound"
    LDAP_QUERY = "ldap_query"


class RelationshipType(Enum):
    """Types of relationships between assets"""
    CONTAINS = "contains"
    RUNS_ON = "runs_on"
    CONNECTS_TO = "connects_to"
    DEPENDS_ON = "depends_on"
    AUTHENTICATES = "authenticates"
    MEMBER_OF = "member_of"
    MANAGES = "manages"
    EXPOSES = "exposes"
    ACCESSES = "accesses"
    TRUSTS = "trusts"
    INHERITS_FROM = "inherits_from"
    ROUTES_TO = "routes_to"
    BACKED_BY = "backed_by"
    PROTECTED_BY = "protected_by"
    PART_OF = "part_of"
    USES = "uses"
    INTEGRATES_WITH = "integrates_with"


@dataclass
class Relationship:
    """Represents a relationship between assets with metadata"""
    relationship_type: RelationshipType
    target_id: str
    discovery_method: Optional[DiscoveryMethod] = None
    confidence: float = 1.0  # 0.0 to 1.0
    discovered_at: datetime = field(default_factory=datetime.now)
    validated: bool = False
    validation_method: Optional[str] = None
    notes: str = ""

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            "relationship_type": self.relationship_type.value,
            "target_id": self.target_id,
            "discovery_method": self.discovery_method.value if self.discovery_method else None,
            "confidence": self.confidence,
            "discovered_at": self.discovered_at.isoformat(),
            "validated": self.validated,
            "validation_method": self.validation_method,
            "notes": self.notes,
        }


@dataclass
class StateTransition:
    """Records a state transition with metadata"""
    from_state: LifecycleState
    to_state: LifecycleState
    timestamp: datetime = field(default_factory=datetime.now)
    trigger: str = ""
    notes: str = ""


@dataclass
class Asset:
    """Base asset class with common properties"""
    id: str
    asset_type: AssetType
    name: str
    properties: Dict[str, Any] = field(default_factory=dict)
    relationships: Dict[str, List[Relationship]] = field(default_factory=dict)
    lifecycle_state: LifecycleState = LifecycleState.DISCOVERED
    discovered_at: datetime = field(default_factory=datetime.now)
    validated_at: Optional[datetime] = None
    discovery_method: DiscoveryMethod = DiscoveryMethod.MANUAL_ENTRY
    confidence: float = 0.5  # 0.0 to 1.0
    risk_score: float = 0.0
    tags: List[str] = field(default_factory=list)
    notes: str = ""
    state_history: List[StateTransition] = field(default_factory=list)

    def __post_init__(self):
        """Initialize asset after creation"""
        if not self.id:
            self.id = str(uuid.uuid4())

    def add_relationship(
        self,
        rel_type: RelationshipType,
        target_id: str,
        discovery_method: Optional[DiscoveryMethod] = None,
        confidence: float = 1.0,
        notes: str = ""
    ):
        """Add a relationship to another asset"""
        if isinstance(rel_type, str):
            rel_type = RelationshipType(rel_type)

        rel_key = rel_type.value
        if rel_key not in self.relationships:
            self.relationships[rel_key] = []

        relationship = Relationship(
            relationship_type=rel_type,
            target_id=target_id,
            discovery_method=discovery_method,
            confidence=confidence,
            notes=notes
        )
        self.relationships[rel_key].append(relationship)

    def get_relationships(self, rel_type: RelationshipType) -> List[Relationship]:
        """Get all relationships of a specific type"""
        if isinstance(rel_type, str):
            rel_type = RelationshipType(rel_type)
        return self.relationships.get(rel_type.value, [])

    def transition_state(self, new_state: LifecycleState, trigger: str = "", notes: str = ""):
        """Transition to a new lifecycle state"""
        # Define valid transitions
        valid_transitions = {
            LifecycleState.UNDISCOVERED: [LifecycleState.DISCOVERED],
            LifecycleState.DISCOVERED: [LifecycleState.VALIDATED, LifecycleState.STALE],
            LifecycleState.VALIDATED: [LifecycleState.ENUMERATED, LifecycleState.STALE],
            LifecycleState.ENUMERATED: [LifecycleState.TESTED, LifecycleState.STALE],
            LifecycleState.TESTED: [LifecycleState.EXPLOITED, LifecycleState.STALE],
            LifecycleState.EXPLOITED: [LifecycleState.CONTROLLED, LifecycleState.CLEANED],
            LifecycleState.CONTROLLED: [LifecycleState.CLEANED],
        }

        if isinstance(new_state, str):
            new_state = LifecycleState(new_state)

        if new_state in valid_transitions.get(self.lifecycle_state, []):
            transition = StateTransition(
                from_state=self.lifecycle_state,
                to_state=new_state,
                trigger=trigger,
                notes=notes
            )
            self.state_history.append(transition)
            self.lifecycle_state = new_state

            if new_state == LifecycleState.VALIDATED:
                self.validated_at = datetime.now()
        else:
            raise ValueError(
                f"Invalid state transition: {self.lifecycle_state.value} â†’ {new_state.value}"
            )

    def update_property(self, key: str, value: Any):
        """Update a property and track the change"""
        self.properties[key] = value

    def get_property(self, key: str, default: Any = None) -> Any:
        """Get a property value"""
        return self.properties.get(key, default)

    def has_property(self, key: str) -> bool:
        """Check if property exists"""
        return key in self.properties

    def matches_condition(self, condition: Dict[str, Any]) -> bool:
        """
        Check if asset matches a condition dictionary.
        Used for trigger detection.

        Example condition:
        {
            "property": "nac_enabled",
            "operator": "equals",
            "value": true
        }
        """
        property_name = condition.get("property")
        operator = condition.get("operator")
        expected_value = condition.get("value")

        if not property_name or not operator:
            return False

        actual_value = self.get_property(property_name)

        if operator == "equals":
            return actual_value == expected_value
        elif operator == "not_equals":
            return actual_value != expected_value
        elif operator == "exists":
            return self.has_property(property_name) and actual_value is not None
        elif operator == "not_exists":
            return not self.has_property(property_name) or actual_value is None
        elif operator == "in":
            values = condition.get("values", [])
            return actual_value in values
        elif operator == "not_in":
            values = condition.get("values", [])
            return actual_value not in values
        elif operator == "greater_than":
            return actual_value > expected_value
        elif operator == "less_than":
            return actual_value < expected_value
        elif operator == "contains":
            if isinstance(actual_value, (list, str)):
                return expected_value in actual_value
            return False

        return False

    def to_dict(self) -> Dict[str, Any]:
        """Convert asset to dictionary"""
        return {
            "id": self.id,
            "asset_type": self.asset_type.value,
            "name": self.name,
            "properties": self.properties,
            "relationships": {
                k: [r.to_dict() for r in v]
                for k, v in self.relationships.items()
            },
            "lifecycle_state": self.lifecycle_state.value,
            "discovered_at": self.discovered_at.isoformat(),
            "validated_at": self.validated_at.isoformat() if self.validated_at else None,
            "discovery_method": self.discovery_method.value,
            "confidence": self.confidence,
            "risk_score": self.risk_score,
            "tags": self.tags,
            "notes": self.notes,
            "state_history": [
                {
                    "from_state": t.from_state.value,
                    "to_state": t.to_state.value,
                    "timestamp": t.timestamp.isoformat(),
                    "trigger": t.trigger,
                    "notes": t.notes,
                }
                for t in self.state_history
            ],
        }

    def to_json(self) -> str:
        """Convert asset to JSON string"""
        return json.dumps(self.to_dict(), indent=2)

    def __repr__(self) -> str:
        return f"<{self.asset_type.value}:{self.name} [{self.lifecycle_state.value}]>"
