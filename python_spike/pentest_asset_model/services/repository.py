"""Asset repository for storing and managing assets"""

from typing import Dict, List, Optional, Any
import json
from collections import defaultdict

from pentest_asset_model.models.base import (
    Asset,
    AssetType,
    LifecycleState,
    RelationshipType,
)


class AssetRepository:
    """
    Central repository for managing penetration testing assets.
    Provides CRUD operations, querying, and relationship management.
    """

    def __init__(self):
        self.assets: Dict[str, Asset] = {}
        self.assets_by_type: Dict[str, List[str]] = defaultdict(list)
        self.relationships: Dict[str, Dict[str, List[str]]] = defaultdict(lambda: defaultdict(list))

    def add_asset(self, asset: Asset) -> Asset:
        """Add or update an asset"""
        asset_id = asset.id

        # If updating existing asset, remove from old type index
        if asset_id in self.assets:
            old_asset = self.assets[asset_id]
            old_type = old_asset.asset_type.value
            if asset_id in self.assets_by_type[old_type]:
                self.assets_by_type[old_type].remove(asset_id)

        # Store asset
        self.assets[asset_id] = asset

        # Index by type
        asset_type = asset.asset_type.value
        if asset_id not in self.assets_by_type[asset_type]:
            self.assets_by_type[asset_type].append(asset_id)

        # Index relationships
        self._index_relationships(asset)

        return asset

    def get_asset(self, asset_id: str) -> Optional[Asset]:
        """Get asset by ID"""
        return self.assets.get(asset_id)

    def remove_asset(self, asset_id: str) -> bool:
        """Remove asset from repository"""
        if asset_id not in self.assets:
            return False

        asset = self.assets[asset_id]
        asset_type = asset.asset_type.value

        # Remove from type index
        if asset_id in self.assets_by_type[asset_type]:
            self.assets_by_type[asset_type].remove(asset_id)

        # Remove relationships
        self._remove_relationships(asset)

        # Remove asset
        del self.assets[asset_id]
        return True

    def find_assets(
        self,
        asset_type: Optional[str] = None,
        lifecycle_state: Optional[str] = None,
        **properties
    ) -> List[Asset]:
        """
        Find assets matching criteria.

        Args:
            asset_type: Filter by asset type
            lifecycle_state: Filter by lifecycle state
            **properties: Filter by property values

        Returns:
            List of matching assets
        """
        # Start with all assets or filtered by type
        if asset_type:
            asset_ids = self.assets_by_type.get(asset_type, [])
            candidates = [self.assets[aid] for aid in asset_ids if aid in self.assets]
        else:
            candidates = list(self.assets.values())

        # Filter by lifecycle state
        if lifecycle_state:
            if isinstance(lifecycle_state, str):
                lifecycle_state = LifecycleState(lifecycle_state)
            candidates = [a for a in candidates if a.lifecycle_state == lifecycle_state]

        # Filter by properties
        for key, value in properties.items():
            candidates = [a for a in candidates if a.get_property(key) == value]

        return candidates

    def find_by_relationship(
        self,
        relationship_type: RelationshipType,
        target_id: Optional[str] = None,
        source_id: Optional[str] = None
    ) -> List[Asset]:
        """
        Find assets by relationship.

        Args:
            relationship_type: Type of relationship
            target_id: Target asset ID (find sources)
            source_id: Source asset ID (find targets)

        Returns:
            List of related assets
        """
        if isinstance(relationship_type, str):
            relationship_type = RelationshipType(relationship_type)

        rel_key = relationship_type.value

        if target_id:
            # Find assets that have this relationship to target
            source_ids = self.relationships[rel_key].get(target_id, [])
            return [self.assets[sid] for sid in source_ids if sid in self.assets]

        elif source_id:
            # Find assets that source has relationship to
            source_asset = self.assets.get(source_id)
            if not source_asset:
                return []

            relationships = source_asset.get_relationships(relationship_type)
            target_ids = [r.target_id for r in relationships]
            return [self.assets[tid] for tid in target_ids if tid in self.assets]

        return []

    def get_related_assets(
        self,
        asset_id: str,
        relationship_type: Optional[RelationshipType] = None,
        depth: int = 1
    ) -> Dict[str, List[Asset]]:
        """
        Get related assets with optional traversal depth.

        Args:
            asset_id: Source asset ID
            relationship_type: Optional relationship type filter
            depth: How many levels deep to traverse

        Returns:
            Dictionary mapping relationship types to lists of assets
        """
        asset = self.get_asset(asset_id)
        if not asset:
            return {}

        related = defaultdict(list)

        # Get direct relationships
        for rel_type, relationships in asset.relationships.items():
            if relationship_type and rel_type != relationship_type.value:
                continue

            for rel in relationships:
                target = self.get_asset(rel.target_id)
                if target:
                    related[rel_type].append(target)

                    # Recursively get relationships if depth > 1
                    if depth > 1:
                        sub_related = self.get_related_assets(
                            rel.target_id,
                            relationship_type,
                            depth - 1
                        )
                        for sub_rel_type, sub_assets in sub_related.items():
                            related[sub_rel_type].extend(sub_assets)

        return dict(related)

    def get_all_assets(self) -> List[Asset]:
        """Get all assets"""
        return list(self.assets.values())

    def get_assets_by_type(self, asset_type: AssetType) -> List[Asset]:
        """Get all assets of a specific type"""
        if isinstance(asset_type, AssetType):
            asset_type = asset_type.value
        asset_ids = self.assets_by_type.get(asset_type, [])
        return [self.assets[aid] for aid in asset_ids if aid in self.assets]

    def get_assets_by_state(self, state: LifecycleState) -> List[Asset]:
        """Get all assets in a specific lifecycle state"""
        if isinstance(state, str):
            state = LifecycleState(state)
        return [a for a in self.assets.values() if a.lifecycle_state == state]

    def count_assets(self) -> int:
        """Get total asset count"""
        return len(self.assets)

    def count_by_type(self) -> Dict[str, int]:
        """Get asset counts by type"""
        return {
            asset_type: len(asset_ids)
            for asset_type, asset_ids in self.assets_by_type.items()
        }

    def count_by_state(self) -> Dict[str, int]:
        """Get asset counts by lifecycle state"""
        counts = defaultdict(int)
        for asset in self.assets.values():
            counts[asset.lifecycle_state.value] += 1
        return dict(counts)

    def export_to_json(self, file_path: str):
        """Export all assets to JSON file"""
        data = {
            "assets": [asset.to_dict() for asset in self.assets.values()],
            "counts": {
                "total": self.count_assets(),
                "by_type": self.count_by_type(),
                "by_state": self.count_by_state(),
            }
        }
        with open(file_path, 'w') as f:
            json.dump(data, f, indent=2)

    def import_from_json(self, file_path: str):
        """Import assets from JSON file"""
        with open(file_path, 'r') as f:
            data = json.load(f)

        # TODO: Implement proper deserialization with asset type detection
        # For now, this is a placeholder
        for asset_dict in data.get("assets", []):
            # This would need proper asset type-specific deserialization
            pass

    def _index_relationships(self, asset: Asset):
        """Index asset relationships for fast lookup"""
        for rel_type, relationships in asset.relationships.items():
            for rel in relationships:
                # Index: relationship_type -> target_id -> [source_ids]
                if asset.id not in self.relationships[rel_type][rel.target_id]:
                    self.relationships[rel_type][rel.target_id].append(asset.id)

    def _remove_relationships(self, asset: Asset):
        """Remove asset relationships from index"""
        for rel_type, relationships in asset.relationships.items():
            for rel in relationships:
                if asset.id in self.relationships[rel_type][rel.target_id]:
                    self.relationships[rel_type][rel.target_id].remove(asset.id)

    def get_statistics(self) -> Dict[str, Any]:
        """Get repository statistics"""
        return {
            "total_assets": self.count_assets(),
            "by_type": self.count_by_type(),
            "by_state": self.count_by_state(),
            "relationship_count": sum(
                len(targets)
                for rel_type in self.relationships.values()
                for targets in rel_type.values()
            )
        }

    def clear(self):
        """Clear all assets from repository"""
        self.assets.clear()
        self.assets_by_type.clear()
        self.relationships.clear()

    def __len__(self) -> int:
        return len(self.assets)

    def __contains__(self, asset_id: str) -> bool:
        return asset_id in self.assets

    def __repr__(self) -> str:
        return f"<AssetRepository: {self.count_assets()} assets>"
