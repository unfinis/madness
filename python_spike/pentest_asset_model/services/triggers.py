"""Trigger detection and methodology orchestration"""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional
import hashlib
import json

from pentest_asset_model.models.base import Asset
from pentest_asset_model.services.repository import AssetRepository


class TriggerStatus(Enum):
    """Trigger execution status"""
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    SKIPPED = "skipped"


@dataclass
class TriggerCondition:
    """Represents a single trigger condition"""
    property: str
    operator: str  # equals, not_equals, exists, in, greater_than, less_than, contains
    value: Any = None
    values: List[Any] = field(default_factory=list)

    def evaluate(self, asset: Asset) -> bool:
        """Evaluate condition against asset"""
        return asset.matches_condition({
            "property": self.property,
            "operator": self.operator,
            "value": self.value,
            "values": self.values
        })


@dataclass
class MethodologyTrigger:
    """Represents a methodology trigger based on asset properties"""
    methodology_id: str
    methodology_name: str
    asset_type: str
    conditions: List[TriggerCondition]
    require_all_conditions: bool = True  # AND vs OR
    deduplication_template: str = "{asset_id}:{methodology_id}"
    batch_capable: bool = False
    batch_key_template: Optional[str] = None
    command_template: Optional[str] = None
    priority: int = 5  # 1-10, higher = more important

    def matches(self, asset: Asset) -> bool:
        """Check if this trigger matches the asset"""
        # Check asset type
        if asset.asset_type.value != self.asset_type:
            return False

        # Evaluate conditions
        results = [condition.evaluate(asset) for condition in self.conditions]

        if self.require_all_conditions:
            return all(results)  # AND
        else:
            return any(results)  # OR

    def generate_deduplication_key(self, asset: Asset) -> str:
        """Generate deduplication key for this trigger + asset combination"""
        # Replace template variables
        key = self.deduplication_template
        key = key.replace("{asset_id}", asset.id)
        key = key.replace("{methodology_id}", self.methodology_id)

        # Add property-based hashing if needed
        if "{properties_hash}" in key:
            # Hash relevant properties
            props = {}
            for condition in self.conditions:
                value = asset.get_property(condition.property)
                props[condition.property] = value

            props_str = json.dumps(props, sort_keys=True)
            props_hash = hashlib.md5(props_str.encode()).hexdigest()[:8]
            key = key.replace("{properties_hash}", props_hash)

        return key

    def generate_batch_key(self, asset: Asset) -> Optional[str]:
        """Generate batch key for grouping similar triggers"""
        if not self.batch_capable or not self.batch_key_template:
            return None

        key = self.batch_key_template
        key = key.replace("{methodology_id}", self.methodology_id)
        key = key.replace("{asset_type}", self.asset_type)

        return key

    def generate_command(self, asset: Asset, **kwargs) -> Optional[str]:
        """Generate command from template with asset properties"""
        if not self.command_template:
            return None

        command = self.command_template

        # Replace asset properties
        for prop_name, prop_value in asset.properties.items():
            placeholder = f"{{{prop_name}}}"
            if placeholder in command:
                command = command.replace(placeholder, str(prop_value))

        # Replace additional variables
        for key, value in kwargs.items():
            placeholder = f"{{{key}}}"
            if placeholder in command:
                command = command.replace(placeholder, str(value))

        return command


@dataclass
class TriggerResult:
    """Result of trigger execution"""
    trigger_key: str
    methodology_id: str
    asset_id: str
    status: TriggerStatus
    started_at: datetime
    completed_at: Optional[datetime] = None
    command: Optional[str] = None
    output: Optional[str] = None
    error: Optional[str] = None
    findings: List[str] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "trigger_key": self.trigger_key,
            "methodology_id": self.methodology_id,
            "asset_id": self.asset_id,
            "status": self.status.value,
            "started_at": self.started_at.isoformat(),
            "completed_at": self.completed_at.isoformat() if self.completed_at else None,
            "command": self.command,
            "output": self.output,
            "error": self.error,
            "findings": self.findings
        }


@dataclass
class BatchTrigger:
    """Represents a batch of similar triggers"""
    methodology_id: str
    batch_key: str
    triggers: List[MethodologyTrigger]
    assets: List[Asset]
    batch_command: Optional[str] = None

    def generate_batch_command(self, command_template: str) -> str:
        """Generate optimized batch command"""
        # This would generate commands like:
        # echo "url1" > targets.txt; echo "url2" >> targets.txt; tool -f targets.txt

        # Extract common data from all assets
        targets = []
        for asset in self.assets:
            # Extract target info based on methodology
            target_info = self._extract_target_info(asset)
            if target_info:
                targets.append(target_info)

        # Generate batch command
        command = command_template
        command = command.replace("{targets}", "\n".join(targets))
        command = command.replace("{target_count}", str(len(targets)))

        return command

    def _extract_target_info(self, asset: Asset) -> Optional[str]:
        """Extract relevant target information from asset"""
        # This is methodology-specific
        # For web services: extract URLs
        # For hosts: extract IPs
        # etc.

        if asset.asset_type.value == "network_segment":
            web_services = asset.get_property("web_services", [])
            if web_services:
                return "\n".join([
                    f"{ws.get('host')}:{ws.get('port')}"
                    for ws in web_services
                ])

        return None


class TriggerEngine:
    """
    Engine for detecting and managing methodology triggers based on asset properties.
    Integrates with the asset-driven trigger system described in ASSET_DRIVEN_TRIGGER_SYSTEM.md
    """

    def __init__(self, repository: AssetRepository):
        self.repository = repository
        self.triggers: List[MethodologyTrigger] = []
        self.completed_triggers: Dict[str, TriggerResult] = {}
        self.pending_triggers: List[tuple[MethodologyTrigger, Asset]] = []

    def register_trigger(self, trigger: MethodologyTrigger):
        """Register a methodology trigger"""
        self.triggers.append(trigger)

    def detect_triggers_for_asset(self, asset: Asset) -> List[MethodologyTrigger]:
        """Detect which triggers match an asset"""
        matched_triggers = []

        for trigger in self.triggers:
            if trigger.matches(asset):
                # Generate deduplication key
                dedup_key = trigger.generate_deduplication_key(asset)

                # Check if already completed
                if not self.is_trigger_completed(dedup_key):
                    matched_triggers.append(trigger)

        return matched_triggers

    def detect_all_triggers(self) -> List[tuple[MethodologyTrigger, Asset]]:
        """Detect triggers for all assets in repository"""
        detected = []

        for asset in self.repository.get_all_assets():
            triggers = self.detect_triggers_for_asset(asset)
            for trigger in triggers:
                detected.append((trigger, asset))

        return detected

    def group_batch_triggers(
        self,
        trigger_asset_pairs: List[tuple[MethodologyTrigger, Asset]]
    ) -> List[BatchTrigger]:
        """Group triggers that can be batched together"""
        batch_groups: Dict[str, BatchTrigger] = {}

        for trigger, asset in trigger_asset_pairs:
            if not trigger.batch_capable:
                continue

            batch_key = trigger.generate_batch_key(asset)
            if not batch_key:
                continue

            if batch_key not in batch_groups:
                batch_groups[batch_key] = BatchTrigger(
                    methodology_id=trigger.methodology_id,
                    batch_key=batch_key,
                    triggers=[],
                    assets=[]
                )

            batch_groups[batch_key].triggers.append(trigger)
            batch_groups[batch_key].assets.append(asset)

        return list(batch_groups.values())

    def mark_completed(
        self,
        trigger_key: str,
        result: TriggerResult
    ):
        """Mark a trigger as completed"""
        self.completed_triggers[trigger_key] = result

    def is_trigger_completed(self, trigger_key: str) -> bool:
        """Check if trigger has been completed"""
        return trigger_key in self.completed_triggers

    def get_trigger_result(self, trigger_key: str) -> Optional[TriggerResult]:
        """Get result for a completed trigger"""
        return self.completed_triggers.get(trigger_key)

    def get_pending_triggers(
        self,
        asset_id: Optional[str] = None,
        methodology_id: Optional[str] = None
    ) -> List[tuple[MethodologyTrigger, Asset]]:
        """Get pending triggers with optional filters"""
        detected = self.detect_all_triggers()

        # Filter by asset_id
        if asset_id:
            detected = [(t, a) for t, a in detected if a.id == asset_id]

        # Filter by methodology_id
        if methodology_id:
            detected = [(t, a) for t, a in detected if t.methodology_id == methodology_id]

        return detected

    def get_statistics(self) -> Dict[str, Any]:
        """Get trigger statistics"""
        detected = self.detect_all_triggers()
        batch_groups = self.group_batch_triggers(detected)

        status_counts = {}
        for result in self.completed_triggers.values():
            status = result.status.value
            status_counts[status] = status_counts.get(status, 0) + 1

        return {
            "registered_methodologies": len(self.triggers),
            "detected_triggers": len(detected),
            "batchable_groups": len(batch_groups),
            "completed_triggers": len(self.completed_triggers),
            "status_breakdown": status_counts
        }

    def create_example_triggers(self):
        """Create example triggers based on common scenarios"""

        # NAC Credential Testing
        self.register_trigger(MethodologyTrigger(
            methodology_id="nac_credential_testing",
            methodology_name="NAC Credential Testing",
            asset_type="network_segment",
            conditions=[
                TriggerCondition("nac_enabled", "equals", True),
                TriggerCondition("credentials_available", "exists"),
                TriggerCondition("access_level", "in", values=["blocked", "limited"])
            ],
            deduplication_template="{asset_id}:nac_cred:{properties_hash}",
            batch_capable=True,
            priority=8
        ))

        # Web Service Enumeration
        self.register_trigger(MethodologyTrigger(
            methodology_id="web_service_enumeration",
            methodology_name="Web Service Enumeration",
            asset_type="network_segment",
            conditions=[
                TriggerCondition("web_services", "exists")
            ],
            deduplication_template="{asset_id}:web_enum",
            batch_capable=True,
            batch_key_template="{methodology_id}:batch",
            command_template="eyewitness --web -f {targets_file} --no-prompt",
            priority=6
        ))

        # SMB Credential Spraying
        self.register_trigger(MethodologyTrigger(
            methodology_id="smb_credential_spray",
            methodology_name="SMB Credential Spraying",
            asset_type="network_segment",
            conditions=[
                TriggerCondition("smb_hosts", "exists"),
                TriggerCondition("credentials_available", "exists")
            ],
            deduplication_template="{asset_id}:smb_spray:{properties_hash}",
            batch_capable=True,
            priority=7
        ))

        # Domain Enumeration
        self.register_trigger(MethodologyTrigger(
            methodology_id="domain_enumeration",
            methodology_name="Active Directory Enumeration",
            asset_type="network_segment",
            conditions=[
                TriggerCondition("domain_controllers", "exists"),
                TriggerCondition("credentials_available", "exists")
            ],
            deduplication_template="{asset_id}:domain_enum",
            priority=9
        ))

        # Vulnerable Service Exploitation
        self.register_trigger(MethodologyTrigger(
            methodology_id="service_exploitation",
            methodology_name="Service Exploitation",
            asset_type="service",
            conditions=[
                TriggerCondition("vulnerabilities", "exists"),
                TriggerCondition("exploited", "equals", False)
            ],
            deduplication_template="{asset_id}:exploit:{properties_hash}",
            priority=9
        ))
