"""Advanced query engine for assets"""

from typing import Any, Callable, Dict, List, Optional
from pentest_asset_model.models.base import Asset, LifecycleState
from pentest_asset_model.services.repository import AssetRepository


class QueryBuilder:
    """Builder for constructing complex asset queries"""

    def __init__(self, repository: AssetRepository):
        self.repository = repository
        self.filters: List[Callable[[Asset], bool]] = []
        self._result_limit: Optional[int] = None
        self._offset: int = 0

    def where(self, property_name: str, operator: str, value: Any) -> 'QueryBuilder':
        """
        Add a property filter.

        Operators: equals, not_equals, greater_than, less_than, in, contains, exists
        """
        def filter_fn(asset: Asset) -> bool:
            actual_value = asset.get_property(property_name)

            if operator == "equals":
                return actual_value == value
            elif operator == "not_equals":
                return actual_value != value
            elif operator == "greater_than":
                return actual_value > value if actual_value is not None else False
            elif operator == "less_than":
                return actual_value < value if actual_value is not None else False
            elif operator == "in":
                return actual_value in value if actual_value is not None else False
            elif operator == "contains":
                if isinstance(actual_value, (list, str)):
                    return value in actual_value
                return False
            elif operator == "exists":
                return asset.has_property(property_name) and actual_value is not None
            elif operator == "not_exists":
                return not asset.has_property(property_name) or actual_value is None
            else:
                return False

        self.filters.append(filter_fn)
        return self

    def where_type(self, asset_type: str) -> 'QueryBuilder':
        """Filter by asset type"""
        def filter_fn(asset: Asset) -> bool:
            return asset.asset_type.value == asset_type

        self.filters.append(filter_fn)
        return self

    def where_state(self, state: LifecycleState) -> 'QueryBuilder':
        """Filter by lifecycle state"""
        if isinstance(state, str):
            state = LifecycleState(state)

        def filter_fn(asset: Asset) -> bool:
            return asset.lifecycle_state == state

        self.filters.append(filter_fn)
        return self

    def where_tag(self, tag: str) -> 'QueryBuilder':
        """Filter by tag"""
        def filter_fn(asset: Asset) -> bool:
            return tag in asset.tags

        self.filters.append(filter_fn)
        return self

    def where_custom(self, filter_fn: Callable[[Asset], bool]) -> 'QueryBuilder':
        """Add custom filter function"""
        self.filters.append(filter_fn)
        return self

    def where_risk_score(self, operator: str, threshold: float) -> 'QueryBuilder':
        """Filter by risk score"""
        def filter_fn(asset: Asset) -> bool:
            if operator == "greater_than":
                return asset.risk_score > threshold
            elif operator == "less_than":
                return asset.risk_score < threshold
            elif operator == "equals":
                return asset.risk_score == threshold
            return False

        self.filters.append(filter_fn)
        return self

    def where_confidence(self, operator: str, threshold: float) -> 'QueryBuilder':
        """Filter by confidence level"""
        def filter_fn(asset: Asset) -> bool:
            if operator == "greater_than":
                return asset.confidence > threshold
            elif operator == "less_than":
                return asset.confidence < threshold
            elif operator == "equals":
                return asset.confidence == threshold
            return False

        self.filters.append(filter_fn)
        return self

    def limit(self, count: int) -> 'QueryBuilder':
        """Limit result count"""
        self._result_limit = count
        return self

    def offset(self, count: int) -> 'QueryBuilder':
        """Skip first N results"""
        self._offset = count
        return self

    def execute(self) -> List[Asset]:
        """Execute the query and return results"""
        # Get all assets
        results = self.repository.get_all_assets()

        # Apply all filters
        for filter_fn in self.filters:
            results = [asset for asset in results if filter_fn(asset)]

        # Apply offset and limit
        if self._offset > 0:
            results = results[self._offset:]
        if self._result_limit is not None:
            results = results[:self._result_limit]

        return results

    def count(self) -> int:
        """Count matching assets without applying limit/offset"""
        results = self.repository.get_all_assets()
        for filter_fn in self.filters:
            results = [asset for asset in results if filter_fn(asset)]
        return len(results)

    def first(self) -> Optional[Asset]:
        """Get first matching asset"""
        results = self.limit(1).execute()
        return results[0] if results else None


class QueryEngine:
    """Advanced query engine for asset repository"""

    def __init__(self, repository: AssetRepository):
        self.repository = repository

    def query(self) -> QueryBuilder:
        """Start building a query"""
        return QueryBuilder(self.repository)

    def find_internet_facing_hosts(self) -> List[Asset]:
        """Find all internet-facing hosts"""
        return self.query() \
            .where_type("host") \
            .where("publicly_accessible", "equals", True) \
            .execute()

    def find_compromised_assets(self) -> List[Asset]:
        """Find all exploited or controlled assets"""
        results = []
        results.extend(
            self.query()
            .where_state(LifecycleState.EXPLOITED)
            .execute()
        )
        results.extend(
            self.query()
            .where_state(LifecycleState.CONTROLLED)
            .execute()
        )
        return results

    def find_high_value_targets(self, risk_threshold: float = 7.0) -> List[Asset]:
        """Find high-value targets based on risk score"""
        return self.query() \
            .where_risk_score("greater_than", risk_threshold) \
            .execute()

    def find_domain_admins(self) -> List[Asset]:
        """Find domain administrator accounts"""
        return self.query() \
            .where_type("user") \
            .where("privilege_level", "in", ["domain_admin", "enterprise_admin"]) \
            .execute()

    def find_valid_credentials(self) -> List[Asset]:
        """Find all valid credentials"""
        return self.query() \
            .where_type("credential") \
            .where("validity_status", "equals", "valid") \
            .execute()

    def find_vulnerable_services(self) -> List[Asset]:
        """Find services with known vulnerabilities"""
        def has_vulnerabilities(asset: Asset) -> bool:
            vulns = asset.get_property("vulnerabilities", [])
            return len(vulns) > 0

        return self.query() \
            .where_type("service") \
            .where_custom(has_vulnerabilities) \
            .execute()

    def find_public_cloud_resources(self) -> List[Asset]:
        """Find publicly accessible cloud resources"""
        buckets = self.query() \
            .where_type("storage_bucket") \
            .where_custom(lambda a: a.is_public() if hasattr(a, 'is_public') else False) \
            .execute()

        instances = self.query() \
            .where_type("cloud_instance") \
            .where_custom(lambda a: a.is_publicly_accessible() if hasattr(a, 'is_publicly_accessible') else False) \
            .execute()

        return buckets + instances

    def find_sensitive_data_stores(self) -> List[Asset]:
        """Find data stores with sensitive information"""
        databases = self.query() \
            .where_type("database") \
            .where_custom(lambda a: a.has_sensitive_data() if hasattr(a, 'has_sensitive_data') else False) \
            .execute()

        file_shares = self.query() \
            .where_type("file_share") \
            .where_custom(lambda a: a.has_sensitive_files() if hasattr(a, 'has_sensitive_files') else False) \
            .execute()

        return databases + file_shares

    def find_untested_assets(self) -> List[Asset]:
        """Find assets that haven't been tested"""
        return self.query() \
            .where_state(LifecycleState.ENUMERATED) \
            .execute()

    def find_windows_hosts(self) -> List[Asset]:
        """Find all Windows hosts"""
        return self.query() \
            .where_type("host") \
            .where("os_type", "equals", "windows") \
            .execute()

    def find_domain_controllers(self) -> List[Asset]:
        """Find all domain controllers"""
        return self.query() \
            .where_type("domain_controller") \
            .execute()

    def find_assets_with_nac(self) -> List[Asset]:
        """Find network segments with NAC enabled"""
        return self.query() \
            .where_type("network_segment") \
            .where("nac_enabled", "equals", True) \
            .execute()

    def search_by_ip(self, ip_address: str) -> List[Asset]:
        """Search for assets by IP address"""
        def matches_ip(asset: Asset) -> bool:
            ips = asset.get_property("ip_addresses", [])
            if isinstance(ips, list):
                return ip_address in ips
            return asset.get_property("ip_address") == ip_address or \
                   asset.get_property("public_ip") == ip_address or \
                   asset.get_property("private_ip") == ip_address

        return self.query() \
            .where_custom(matches_ip) \
            .execute()

    def search_by_hostname(self, hostname: str) -> List[Asset]:
        """Search for assets by hostname"""
        def matches_hostname(asset: Asset) -> bool:
            return asset.get_property("hostname") == hostname or \
                   asset.get_property("fqdn") == hostname or \
                   asset.name == hostname

        return self.query() \
            .where_custom(matches_hostname) \
            .execute()

    def get_attack_surface(self) -> Dict[str, List[Asset]]:
        """Get the current attack surface"""
        return {
            "internet_facing": self.find_internet_facing_hosts(),
            "vulnerable_services": self.find_vulnerable_services(),
            "public_cloud_resources": self.find_public_cloud_resources(),
            "valid_credentials": self.find_valid_credentials(),
            "compromised_assets": self.find_compromised_assets(),
        }

    def get_statistics(self) -> Dict[str, Any]:
        """Get query statistics"""
        return {
            "total_assets": self.repository.count_assets(),
            "by_type": self.repository.count_by_type(),
            "by_state": self.repository.count_by_state(),
            "high_value_targets": len(self.find_high_value_targets()),
            "compromised": len(self.find_compromised_assets()),
            "vulnerable_services": len(self.find_vulnerable_services()),
            "valid_credentials": len(self.find_valid_credentials()),
        }
