import 'dart:ui' as ui;
import 'dart:io';
import 'dart:typed_data';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../models/screenshot.dart';
import '../../models/canvas_state.dart';
import '../../models/editor_tool.dart';
import '../../models/editor_layer.dart';

class EditorCanvas extends ConsumerStatefulWidget {
  final String screenshotId;
  final String projectId;
  final EditorTool selectedTool;
  final ToolConfig toolConfig;
  final ValueChanged<String?> onLayerSelected;

  const EditorCanvas({
    super.key,
    required this.screenshotId,
    required this.projectId,
    required this.selectedTool,
    required this.toolConfig,
    required this.onLayerSelected,
  });

  @override
  ConsumerState<EditorCanvas> createState() => EditorCanvasState();
}

class EditorCanvasState extends ConsumerState<EditorCanvas> {
  CanvasState _canvasState = CanvasState.initial();
  ui.Image? _backgroundImage;
  bool _isLoading = true;
  String? _selectedLayerId;
  
  // Drawing state
  Offset? _dragStart;
  Offset? _dragCurrent;
  bool _isPanning = false;
  bool _isDrawing = false;
  EditorLayer? _currentDrawingLayer;

  @override
  void initState() {
    super.initState();
    _loadScreenshotImage();
  }

  Future<void> _loadScreenshotImage() async {
    try {
      setState(() {
        _isLoading = true;
      });

      // For now, create a placeholder image - will be replaced with actual image loading
      final image = await _createPlaceholderImage();
      
      setState(() {
        _backgroundImage = image;
        _canvasState = _canvasState.copyWith(
          imageSize: Size(image.width.toDouble(), image.height.toDouble()),
        );
        _isLoading = false;
      });
      
      // Fit the image to canvas on initial load
      WidgetsBinding.instance.addPostFrameCallback((_) {
        fitToCanvas();
      });
    } catch (e) {
      setState(() {
        _isLoading = false;
      });
      // Handle error - show placeholder or error message
    }
  }

  Future<ui.Image> _createPlaceholderImage() async {
    final recorder = ui.PictureRecorder();
    final canvas = Canvas(recorder, const Rect.fromLTWH(0, 0, 800, 600));
    
    // Draw a placeholder background
    final paint = Paint()..color = Colors.grey.shade100;
    canvas.drawRect(const Rect.fromLTWH(0, 0, 800, 600), paint);
    
    // Draw a border
    paint
      ..color = Colors.grey.shade400
      ..style = PaintingStyle.stroke
      ..strokeWidth = 2;
    canvas.drawRect(const Rect.fromLTWH(1, 1, 798, 598), paint);
    
    // Draw placeholder text
    final textPainter = TextPainter(
      text: const TextSpan(
        text: 'Screenshot Placeholder\n\nImage loading functionality\nwill be implemented here',
        style: TextStyle(
          color: Colors.black54,
          fontSize: 24,
        ),
      ),
      textDirection: TextDirection.ltr,
      textAlign: TextAlign.center,
    );
    textPainter.layout();
    textPainter.paint(
      canvas,
      Offset(
        (800 - textPainter.width) / 2,
        (600 - textPainter.height) / 2,
      ),
    );
    
    final picture = recorder.endRecording();
    return await picture.toImage(800, 600);
  }

  // Canvas control methods
  void zoomIn() {
    setState(() {
      _canvasState = _canvasState.zoomIn();
    });
  }

  void zoomOut() {
    setState(() {
      _canvasState = _canvasState.zoomOut();
    });
  }

  void setZoom(double zoom) {
    setState(() {
      _canvasState = _canvasState.zoomTo(zoom);
    });
  }

  void fitToCanvas() {
    setState(() {
      _canvasState = _canvasState.fitToCanvas();
    });
  }

  void actualSize() {
    setState(() {
      _canvasState = _canvasState.actualSize();
    });
  }

  void undo() {
    // TODO: Implement undo functionality
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('Undo functionality coming soon')),
    );
  }

  void redo() {
    // TODO: Implement redo functionality
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('Redo functionality coming soon')),
    );
  }

  void deleteLayer(String layerId) {
    // TODO: Implement layer deletion
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text('Deleted layer $layerId')),
    );
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoading) {
      return const Center(
        child: CircularProgressIndicator(),
      );
    }

    return LayoutBuilder(
      builder: (context, constraints) {
        // Update canvas size when layout changes
        final newCanvasSize = Size(constraints.maxWidth, constraints.maxHeight);
        if (_canvasState.canvasSize != newCanvasSize) {
          WidgetsBinding.instance.addPostFrameCallback((_) {
            setState(() {
              _canvasState = _canvasState.copyWith(canvasSize: newCanvasSize);
            });
          });
        }

        return GestureDetector(
          onScaleStart: _handleScaleStart,
          onScaleUpdate: _handleScaleUpdate,
          onScaleEnd: _handleScaleEnd,
          onTapDown: _handleTapDown,
          onTapUp: _handleTapUp,
          child: CustomPaint(
            size: Size.infinite,
            painter: EditorCanvasPainter(
              canvasState: _canvasState,
              backgroundImage: _backgroundImage,
              layers: [], // TODO: Get from provider
              selectedLayerId: _selectedLayerId,
              currentDrawingLayer: _currentDrawingLayer,
            ),
          ),
        );
      },
    );
  }

  void _handleScaleStart(ScaleStartDetails details) {
    final canvasPoint = _canvasState.screenToCanvas(details.focalPoint);
    
    setState(() {
      _dragStart = details.focalPoint;
      _dragCurrent = details.focalPoint;
    });

    if (widget.selectedTool == EditorTool.pan) {
      _isPanning = true;
    } else if (widget.selectedTool.isAnnotationTool || widget.selectedTool.isRedactionTool || widget.selectedTool.isShapeTool) {
      _startDrawing(canvasPoint);
    }
  }

  void _handleScaleUpdate(ScaleUpdateDetails details) {
    if (_isPanning) {
      final delta = details.focalPoint - (_dragCurrent ?? details.focalPoint);
      setState(() {
        _canvasState = _canvasState.panBy(delta);
        _dragCurrent = details.focalPoint;
      });
    } else if (details.scale != 1.0) {
      // Handle zoom
      final newZoom = _canvasState.zoom * details.scale;
      setState(() {
        _canvasState = _canvasState.zoomTo(newZoom, center: details.focalPoint);
      });
    } else if (_isDrawing) {
      final canvasPoint = _canvasState.screenToCanvas(details.focalPoint);
      _updateDrawing(canvasPoint);
    }
  }

  void _handleScaleEnd(ScaleEndDetails details) {
    if (_isDrawing) {
      _finishDrawing();
    }
    
    setState(() {
      _isPanning = false;
      _isDrawing = false;
      _dragStart = null;
      _dragCurrent = null;
    });
  }

  void _handleTapDown(TapDownDetails details) {
    if (widget.selectedTool == EditorTool.select) {
      final canvasPoint = _canvasState.screenToCanvas(details.localPosition);
      // TODO: Check for layer selection at this point
      widget.onLayerSelected(null);
    }
  }

  void _handleTapUp(TapUpDetails details) {
    if (widget.selectedTool == EditorTool.text) {
      final canvasPoint = _canvasState.screenToCanvas(details.localPosition);
      _showTextInput(canvasPoint);
    }
  }

  void _startDrawing(Offset canvasPoint) {
    _isDrawing = true;
    
    // Create appropriate layer based on selected tool
    switch (widget.selectedTool) {
      case EditorTool.highlightRect:
        _currentDrawingLayer = VectorLayer(
          id: DateTime.now().millisecondsSinceEpoch.toString(),
          name: 'Highlight ${DateTime.now().millisecond}',
          visible: true,
          locked: false,
          opacity: widget.toolConfig.opacity,
          blendMode: BlendMode.multiply,
          createdAt: DateTime.now(),
          modifiedAt: DateTime.now(),
          points: [canvasPoint],
          strokeWidth: widget.toolConfig.strokeWidth,
          strokeColor: widget.toolConfig.primaryColor,
          fillColor: widget.toolConfig.primaryColor.withOpacity(0.3),
          vectorType: VectorType.rectangle,
        );
        break;
        
      case EditorTool.arrow:
        _currentDrawingLayer = VectorLayer(
          id: DateTime.now().millisecondsSinceEpoch.toString(),
          name: 'Arrow ${DateTime.now().millisecond}',
          visible: true,
          locked: false,
          opacity: widget.toolConfig.opacity,
          blendMode: BlendMode.srcOver,
          createdAt: DateTime.now(),
          modifiedAt: DateTime.now(),
          points: [canvasPoint],
          strokeWidth: widget.toolConfig.strokeWidth,
          strokeColor: widget.toolConfig.primaryColor,
          fillColor: Colors.transparent,
          vectorType: VectorType.arrow,
        );
        break;
        
      case EditorTool.redactBlackout:
        _currentDrawingLayer = RedactionLayer(
          id: DateTime.now().millisecondsSinceEpoch.toString(),
          name: 'Blackout ${DateTime.now().millisecond}',
          visible: true,
          locked: false,
          opacity: widget.toolConfig.opacity,
          blendMode: BlendMode.srcOver,
          createdAt: DateTime.now(),
          modifiedAt: DateTime.now(),
          bounds: Rect.fromPoints(canvasPoint, canvasPoint),
          redactionType: RedactionType.blackout,
        );
        break;
        
      default:
        break;
    }
  }

  void _updateDrawing(Offset canvasPoint) {
    if (_currentDrawingLayer == null || _dragStart == null) return;

    setState(() {
      if (_currentDrawingLayer is VectorLayer) {
        final vectorLayer = _currentDrawingLayer as VectorLayer;
        _currentDrawingLayer = vectorLayer.copyWith(
          points: [
            _canvasState.screenToCanvas(_dragStart!),
            canvasPoint,
          ],
        ) as VectorLayer;
      } else if (_currentDrawingLayer is RedactionLayer) {
        final redactionLayer = _currentDrawingLayer as RedactionLayer;
        final startPoint = _canvasState.screenToCanvas(_dragStart!);
        _currentDrawingLayer = redactionLayer.copyWith(
          bounds: Rect.fromPoints(startPoint, canvasPoint),
        ) as RedactionLayer;
      }
    });
  }

  void _finishDrawing() {
    if (_currentDrawingLayer != null) {
      // TODO: Add layer to screenshot via provider
      setState(() {
        _selectedLayerId = _currentDrawingLayer!.id;
        _currentDrawingLayer = null;
      });
      widget.onLayerSelected(_selectedLayerId);
    }
  }

  void _showTextInput(Offset canvasPoint) {
    showDialog(
      context: context,
      builder: (context) {
        String text = '';
        return AlertDialog(
          title: const Text('Add Text'),
          content: TextField(
            autofocus: true,
            decoration: const InputDecoration(
              hintText: 'Enter text...',
              border: OutlineInputBorder(),
            ),
            onChanged: (value) => text = value,
            onSubmitted: (value) {
              if (value.isNotEmpty) {
                _addTextLayer(canvasPoint, value);
              }
              Navigator.of(context).pop();
            },
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text('Cancel'),
            ),
            TextButton(
              onPressed: () {
                if (text.isNotEmpty) {
                  _addTextLayer(canvasPoint, text);
                }
                Navigator.of(context).pop();
              },
              child: const Text('Add'),
            ),
          ],
        );
      },
    );
  }

  void _addTextLayer(Offset position, String text) {
    final textLayer = TextLayer(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      name: 'Text ${DateTime.now().millisecond}',
      visible: true,
      locked: false,
      opacity: widget.toolConfig.opacity,
      blendMode: BlendMode.srcOver,
      createdAt: DateTime.now(),
      modifiedAt: DateTime.now(),
      text: text,
      position: position,
      fontSize: widget.toolConfig.toolSpecificSettings['fontSize'] ?? 16.0,
      fontFamily: widget.toolConfig.toolSpecificSettings['fontFamily'] ?? 'Arial',
      fontWeight: (widget.toolConfig.toolSpecificSettings['bold'] ?? false) 
          ? FontWeight.bold 
          : FontWeight.normal,
      fontStyle: (widget.toolConfig.toolSpecificSettings['italic'] ?? false) 
          ? FontStyle.italic 
          : FontStyle.normal,
      color: widget.toolConfig.primaryColor,
      backgroundColor: widget.toolConfig.secondaryColor,
      alignment: TextAlign.left,
    );

    // TODO: Add layer via provider
    setState(() {
      _selectedLayerId = textLayer.id;
    });
    widget.onLayerSelected(_selectedLayerId);
  }
}

class EditorCanvasPainter extends CustomPainter {
  final CanvasState canvasState;
  final ui.Image? backgroundImage;
  final List<EditorLayer> layers;
  final String? selectedLayerId;
  final EditorLayer? currentDrawingLayer;

  EditorCanvasPainter({
    required this.canvasState,
    this.backgroundImage,
    required this.layers,
    this.selectedLayerId,
    this.currentDrawingLayer,
  });

  @override
  void paint(Canvas canvas, Size size) {
    // Update canvas state size if needed
    if (canvasState.canvasSize != size) {
      // This should be handled by the widget, not here
    }

    // Apply transformation matrix
    canvas.save();
    canvas.transform(canvasState.transformMatrix.storage);

    // Draw background image
    if (backgroundImage != null) {
      final paint = Paint();
      canvas.drawImage(backgroundImage!, Offset.zero, paint);
    }

    // Draw existing layers
    for (final layer in layers) {
      if (layer.visible) {
        _drawLayer(canvas, layer);
      }
    }

    // Draw current drawing layer (preview)
    if (currentDrawingLayer != null) {
      _drawLayer(canvas, currentDrawingLayer!);
    }

    canvas.restore();

    // Draw selection indicators (in screen space)
    if (selectedLayerId != null) {
      _drawSelectionIndicator(canvas, size);
    }

    // Draw grid if enabled
    if (canvasState.showGrid) {
      _drawGrid(canvas, size);
    }
  }

  void _drawLayer(Canvas canvas, EditorLayer layer) {
    final paint = Paint()
      ..color = Colors.black
      ..blendMode = layer.blendMode;

    // Set opacity
    if (layer.opacity < 1.0) {
      canvas.saveLayer(null, paint..color = paint.color.withOpacity(layer.opacity));
    }

    // Render the layer
    layer.render(canvas, paint);

    if (layer.opacity < 1.0) {
      canvas.restore();
    }
  }

  void _drawSelectionIndicator(Canvas canvas, Size size) {
    // TODO: Draw selection handles around selected layer
  }

  void _drawGrid(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = canvasState.gridColor
      ..strokeWidth = 0.5;

    // Draw vertical grid lines
    for (final x in canvasState.gridLinesX) {
      final screenX = canvasState.canvasToScreen(Offset(x, 0)).dx;
      canvas.drawLine(
        Offset(screenX, 0),
        Offset(screenX, size.height),
        paint,
      );
    }

    // Draw horizontal grid lines
    for (final y in canvasState.gridLinesY) {
      final screenY = canvasState.canvasToScreen(Offset(0, y)).dy;
      canvas.drawLine(
        Offset(0, screenY),
        Offset(size.width, screenY),
        paint,
      );
    }
  }

  @override
  bool shouldRepaint(covariant EditorCanvasPainter oldDelegate) {
    return oldDelegate.canvasState != canvasState ||
        oldDelegate.backgroundImage != backgroundImage ||
        oldDelegate.layers != layers ||
        oldDelegate.selectedLayerId != selectedLayerId ||
        oldDelegate.currentDrawingLayer != currentDrawingLayer;
  }
}